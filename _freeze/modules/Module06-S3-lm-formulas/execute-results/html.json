{
  "hash": "798086851969646f1ef80f62629015b5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 6: S3 and R Formulas\"\nformat:\n  revealjs:\n    toc: false\n---\n\n\n\n\n\n\n## Learning goals\n\n1. Explain what S3 is and give an example of an S3 method\n1. Understand the R help pages for S3 methods\n1. Use vectorization to replace unnecessary loops\n1. Understand when and how to use the R formula syntax\n1. Write basic linear models with R formulas\n\n# Part 1: S3 stands for 3/10 Scariness\n\n## Objects and classes and methods {.incremental}\n\n- We've talked about imperative programming and functional programming. Now we'll talk about **object-oriented programming.**\n- S3 is a \"functional OOP\" system, which is different from OOP you might have dealt with in Python or C++.\n- The main propery of S3 is **polymorphism**: one **generic function** can act differently on different **classes** of objects, but symbolically represents the same thing and has a consistent interface.\n\n## An S3 example {.scrollable}\n\n\n\n\n\n\n\n\n\n- `summary()` is an example of an S3 **generic**. And the documentation tells us this.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject Summaries\n\nDescription:\n\n     'summary' is a generic function used to produce result summaries\n     of the results of various model fitting functions.  The function\n     invokes particular 'methods' which depend on the 'class' of the\n     first argument.\n\nUsage:\n\n     summary(object, ...)\n     \n     ## Default S3 method:\n     summary(object, ..., digits, quantile.type = 7)\n     ## S3 method for class 'data.frame'\n     summary(object, maxsum = 7,\n            digits = max(3, getOption(\"digits\")-3), ...)\n     \n     ## S3 method for class 'factor'\n     summary(object, maxsum = 100, ...)\n     \n     ## S3 method for class 'matrix'\n     summary(object, ...)\n     \n     ## S3 method for class 'summaryDefault'\n     format(x, digits = max(3L, getOption(\"digits\") - 3L), zdigits = 4L, ...)\n      ## S3 method for class 'summaryDefault'\n     print(x, digits = max(3L, getOption(\"digits\") - 3L), zdigits = 4L, ...)\n     \nArguments:\n\n  object: an object for which a summary is desired.\n\n       x: a result of the _default_ method of 'summary()'.\n\n  maxsum: integer, indicating how many levels should be shown for\n          'factor's.\n\n  digits: integer (or 'NULL', see 'Details'), used for number\n          formatting with 'signif()' (for 'summary.default') or\n          'format()' (for 'summary.data.frame').  In 'summary.default',\n          if not specified (i.e., 'missing(.)'), 'signif()' will _not_\n          be called anymore (since R >= 3.4.0, where the default has\n          been changed to only round in the 'print' and 'format'\n          methods).\n\n zdigits: integer, typically positive to be used in the internal\n          'zapsmall(*, digits = digits + zdigits)' call.\n\nquantile.type: integer code used in 'quantile(*, type=quantile.type)'\n          for the default method.\n\n     ...: additional arguments affecting the summary produced.\n\nDetails:\n\n     For 'factor's, the frequency of the first 'maxsum - 1' most\n     frequent levels is shown, and the less frequent levels are\n     summarized in '\"(Others)\"' (resulting in at most 'maxsum'\n     frequencies).\n\n     The 'digits' argument may be 'NULL' for some methods specifying to\n     use the default value, e.g., for the '\"summaryDefault\"' 'format()'\n     method.\n\n     The functions 'summary.lm' and 'summary.glm' are examples of\n     particular methods which summarize the results produced by 'lm'\n     and 'glm'.\n\nValue:\n\n     The form of the value returned by 'summary' depends on the class\n     of its argument.  See the documentation of the particular methods\n     for details of what is produced by that method.\n\n     The default method returns an object of class 'c(\"summaryDefault\",\n     \"table\")' which has specialized 'format' and 'print' methods.  The\n     'factor' method returns an integer vector.\n\n     The matrix and data frame methods return a matrix of class\n     '\"table\"', obtained by applying 'summary' to each column and\n     collating the results.\n\nReferences:\n\n     Chambers, J. M. and Hastie, T. J. (1992) _Statistical Models in\n     S_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'anova', 'summary.glm', 'summary.lm'.\n\nExamples:\n\n     summary(attenu, digits = 4) #-> summary.data.frame(...), default precision\n     summary(attenu $ station, maxsum = 20) #-> summary.factor(...)\n     \n     lst <- unclass(attenu$station) > 20 # logical with NAs\n     ## summary.default() for logicals -- different from *.factor:\n     summary(lst)\n     summary(as.factor(lst))\n     \n     ## show the effect of zdigits for skewed data\n     set.seed(17); x <- rlnorm(100, sdlog=2)\n     dput(sx <- summary(x))\n     sx # exponential format for this data\n     print(sx, zdigits = 3) # fixed point: \"more readable\"\n```\n\n\n:::\n:::\n\n\n\n\n## Polymorphism of summary {.scrollable}\n\n- When we call `summary(an_object)` it determines what it should do based on the class of `an_object`.\n- Each of the following summaries shows us different statistics.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(an_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(an_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = bwt ~ age, data = birthwt)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2294.78  -517.63    10.51   530.80  1774.92 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  2655.74     238.86   11.12   <2e-16 ***\nage            12.43      10.02    1.24    0.216    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 728.2 on 187 degrees of freedom\nMultiple R-squared:  0.008157,\tAdjusted R-squared:  0.002853 \nF-statistic: 1.538 on 1 and 187 DF,  p-value: 0.2165\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(a_glm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"glm\" \"lm\" \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(a_glm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = low ~ age, family = \"binomial\", data = birthwt)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)\n(Intercept)  0.38458    0.73212   0.525    0.599\nage         -0.05115    0.03151  -1.623    0.105\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 234.67  on 188  degrees of freedom\nResidual deviance: 231.91  on 187  degrees of freedom\nAIC: 235.91\n\nNumber of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(a_glmm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"glmerMod\"\nattr(,\"package\")\n[1] \"lme4\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(a_glmm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeneralized linear mixed model fit by maximum likelihood (Laplace\n  Approximation) [glmerMod]\n Family: binomial  ( logit )\nFormula: low ~ age + (1 | id)\n   Data: birthwt\n\n      AIC       BIC    logLik -2*log(L)  df.resid \n    237.9     247.6    -116.0     231.9       186 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-0.8451 -0.7066 -0.5908  1.3042  1.9639 \n\nRandom effects:\n Groups Name        Variance Std.Dev.\n id     (Intercept) 0.009912 0.09956 \nNumber of obs: 189, groups:  id, 189\n\nFixed effects:\n            Estimate Std. Error z value Pr(>|z|)\n(Intercept)  0.38540    0.73534   0.524    0.600\nage         -0.05127    0.03234  -1.585    0.113\n\nCorrelation of Fixed Effects:\n    (Intr)\nage -0.966\n```\n\n\n:::\n:::\n\n\n\n\n## Some OOP definitions {.smaller}\n\n- A **class** is a category of object. Objects of the same class have the same **fields** or attributes.\n- A **generic** is a function that has different behavior for multiple classes of inputs.\n- The **methods** for a function are the function implementations for specific classes.\n- **Method dispatch** is the process where you call a generic function, the generic function checks the class of the input, and the generic function calls the method for that class.\n- A **default method** is dispatched by a generic function when there is no specific method for the class of the input. Not every generic has a default method.\n\n## S3 classes {.incremental}\n\n- Everything that exists in R is an object and has a **type**.\n- But not everything is an S3 object, and only S3 objects have a **class**.\n- This is confusing, because the function `class()` will tell you something for every object, no matter what. **If an object does not have a class, `class()` will return the type.**\n- To check if an object *has* an S3 class, you have to check the extremely confusing `attr(an_object, \"class\")` instead.\n\n## S3 classes (and types)\n\n- These objects have types but not classes: `NULL`, vectors, lists, functions, and some other special ones that you won't use.\n- You can pretty much pretend that types are classes.\n\n## S3 classes (and types)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nan_object <- 1:10\ntypeof(an_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(an_object)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(an_object, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n\n\n\n## S3 classes (and types)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(an_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(an_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm\"\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(an_lm, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm\"\n```\n\n\n:::\n:::\n\n\n\n\n## S3 classes (and types) {.scrollable}\n\n- If an object has an S3 class, then it is a list.\n- The only things that aren't lists are the other special objects with types.\n- Complicated S3 classes are just lists where the elements have specific names.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(an_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 12\n $ coefficients : Named num [1:2] 2655.7 12.4\n  ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"age\"\n $ residuals    : Named num [1:189] -369 -515 -347 -323 -279 ...\n  ..- attr(*, \"names\")= chr [1:189] \"85\" \"86\" \"87\" \"88\" ...\n $ effects      : Named num [1:189] -40481 -903 -340 -309 -284 ...\n  ..- attr(*, \"names\")= chr [1:189] \"(Intercept)\" \"age\" \"\" \"\" ...\n $ rank         : int 2\n $ fitted.values: Named num [1:189] 2892 3066 2904 2917 2879 ...\n  ..- attr(*, \"names\")= chr [1:189] \"85\" \"86\" \"87\" \"88\" ...\n $ assign       : int [1:2] 0 1\n $ qr           :List of 5\n  ..$ qr   : num [1:189, 1:2] -13.7477 0.0727 0.0727 0.0727 0.0727 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:189] \"85\" \"86\" \"87\" \"88\" ...\n  .. .. ..$ : chr [1:2] \"(Intercept)\" \"age\"\n  .. ..- attr(*, \"assign\")= int [1:2] 0 1\n  ..$ qraux: num [1:2] 1.07 1.14\n  ..$ pivot: int [1:2] 1 2\n  ..$ tol  : num 1e-07\n  ..$ rank : int 2\n  ..- attr(*, \"class\")= chr \"qr\"\n $ df.residual  : int 187\n $ xlevels      : Named list()\n $ call         : language lm(formula = bwt ~ age, data = birthwt)\n $ terms        :Classes 'terms', 'formula'  language bwt ~ age\n  .. ..- attr(*, \"variables\")= language list(bwt, age)\n  .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. ..$ : chr [1:2] \"bwt\" \"age\"\n  .. .. .. ..$ : chr \"age\"\n  .. ..- attr(*, \"term.labels\")= chr \"age\"\n  .. ..- attr(*, \"order\")= int 1\n  .. ..- attr(*, \"intercept\")= int 1\n  .. ..- attr(*, \"response\")= int 1\n  .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n  .. ..- attr(*, \"predvars\")= language list(bwt, age)\n  .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. ..- attr(*, \"names\")= chr [1:2] \"bwt\" \"age\"\n $ model        :'data.frame':\t189 obs. of  2 variables:\n  ..$ bwt: int [1:189] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n  ..$ age: int [1:189] 19 33 20 21 18 21 22 17 29 26 ...\n  ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language bwt ~ age\n  .. .. ..- attr(*, \"variables\")= language list(bwt, age)\n  .. .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. .. ..$ : chr [1:2] \"bwt\" \"age\"\n  .. .. .. .. ..$ : chr \"age\"\n  .. .. ..- attr(*, \"term.labels\")= chr \"age\"\n  .. .. ..- attr(*, \"order\")= int 1\n  .. .. ..- attr(*, \"intercept\")= int 1\n  .. .. ..- attr(*, \"response\")= int 1\n  .. .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n  .. .. ..- attr(*, \"predvars\")= language list(bwt, age)\n  .. .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. .. ..- attr(*, \"names\")= chr [1:2] \"bwt\" \"age\"\n - attr(*, \"class\")= chr \"lm\"\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?lm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFitting Linear Models\n\nDescription:\n\n     'lm' is used to fit linear models, including multivariate ones.\n     It can be used to carry out regression, single stratum analysis of\n     variance and analysis of covariance (although 'aov' may provide a\n     more convenient interface for these).\n\nUsage:\n\n     lm(formula, data, subset, weights, na.action,\n        method = \"qr\", model = TRUE, x = FALSE, y = FALSE, qr = TRUE,\n        singular.ok = TRUE, contrasts = NULL, offset, ...)\n     \n     ## S3 method for class 'lm'\n     print(x, digits = max(3L, getOption(\"digits\") - 3L), ...)\n     \nArguments:\n\n formula: an object of class '\"formula\"' (or one that can be coerced to\n          that class): a symbolic description of the model to be\n          fitted.  The details of model specification are given under\n          'Details'.\n\n    data: an optional data frame, list or environment (or object\n          coercible by 'as.data.frame' to a data frame) containing the\n          variables in the model.  If not found in 'data', the\n          variables are taken from 'environment(formula)', typically\n          the environment from which 'lm' is called.\n\n  subset: an optional vector specifying a subset of observations to be\n          used in the fitting process.  (See additional details about\n          how this argument interacts with data-dependent bases in the\n          'Details' section of the 'model.frame' documentation.)\n\n weights: an optional vector of weights to be used in the fitting\n          process.  Should be 'NULL' or a numeric vector.  If non-NULL,\n          weighted least squares is used with weights 'weights' (that\n          is, minimizing 'sum(w*e^2)'); otherwise ordinary least\n          squares is used.  See also 'Details',\n\nna.action: a function which indicates what should happen when the data\n          contain 'NA's.  The default is set by the 'na.action' setting\n          of 'options', and is 'na.fail' if that is unset.  The\n          'factory-fresh' default is 'na.omit'.  Another possible value\n          is 'NULL', no action.  Value 'na.exclude' can be useful.\n\n  method: the method to be used; for fitting, currently only 'method =\n          \"qr\"' is supported; 'method = \"model.frame\"' returns the\n          model frame (the same as with 'model = TRUE', see below).\n\nmodel, x, y, qr: logicals.  If 'TRUE' the corresponding components of\n          the fit (the model frame, the model matrix, the response, the\n          QR decomposition) are returned.\n\nsingular.ok: logical. If 'FALSE' (the default in S but not in R) a\n          singular fit is an error.\n\ncontrasts: an optional list. See the 'contrasts.arg' of\n          'model.matrix.default'.\n\n  offset: this can be used to specify an _a priori_ known component to\n          be included in the linear predictor during fitting.  This\n          should be 'NULL' or a numeric vector or matrix of extents\n          matching those of the response.  One or more 'offset' terms\n          can be included in the formula instead or as well, and if\n          more than one are specified their sum is used.  See\n          'model.offset'.\n\n     ...: For 'lm()': additional arguments to be passed to the low\n          level regression fitting functions (see below).\n\n  digits: the number of _significant_ digits to be passed to\n          'format(coef(x), .)' when 'print()'ing.\n\nDetails:\n\n     Models for 'lm' are specified symbolically.  A typical model has\n     the form 'response ~ terms' where 'response' is the (numeric)\n     response vector and 'terms' is a series of terms which specifies a\n     linear predictor for 'response'.  A terms specification of the\n     form 'first + second' indicates all the terms in 'first' together\n     with all the terms in 'second' with duplicates removed.  A\n     specification of the form 'first:second' indicates the set of\n     terms obtained by taking the interactions of all terms in 'first'\n     with all terms in 'second'.  The specification 'first*second'\n     indicates the _cross_ of 'first' and 'second'.  This is the same\n     as 'first + second + first:second'.\n\n     If the formula includes an 'offset', this is evaluated and\n     subtracted from the response.\n\n     If 'response' is a matrix a linear model is fitted separately by\n     least-squares to each column of the matrix and the result inherits\n     from '\"mlm\"' (\"multivariate linear model\").\n\n     See 'model.matrix' for some further details.  The terms in the\n     formula will be re-ordered so that main effects come first,\n     followed by the interactions, all second-order, all third-order\n     and so on: to avoid this pass a 'terms' object as the formula (see\n     'aov' and 'demo(glm.vr)' for an example).\n\n     A formula has an implied intercept term.  To remove this use\n     either 'y ~ x - 1' or 'y ~ 0 + x'.  See 'formula' for more details\n     of allowed formulae.\n\n     Non-'NULL' 'weights' can be used to indicate that different\n     observations have different variances (with the values in\n     'weights' being inversely proportional to the variances); or\n     equivalently, when the elements of 'weights' are positive integers\n     w_i, that each response y_i is the mean of w_i unit-weight\n     observations (including the case that there are w_i observations\n     equal to y_i and the data have been summarized). However, in the\n     latter case, notice that within-group variation is not used.\n     Therefore, the sigma estimate and residual degrees of freedom may\n     be suboptimal; in the case of replication weights, even wrong.\n     Hence, standard errors and analysis of variance tables should be\n     treated with care.\n\n     'lm' calls the lower level functions 'lm.fit', etc, see below, for\n     the actual numerical computations.  For programming only, you may\n     consider doing likewise.\n\n     All of 'weights', 'subset' and 'offset' are evaluated in the same\n     way as variables in 'formula', that is first in 'data' and then in\n     the environment of 'formula'.\n\nValue:\n\n     'lm' returns an object of 'class' '\"lm\"' or for multivariate\n     ('multiple') responses of class 'c(\"mlm\", \"lm\")'.\n\n     The functions 'summary' and 'anova' are used to obtain and print a\n     summary and analysis of variance table of the results.  The\n     generic accessor functions 'coefficients', 'effects',\n     'fitted.values' and 'residuals' extract various useful features of\n     the value returned by 'lm'.\n\n     An object of class '\"lm\"' is a list containing at least the\n     following components:\n\ncoefficients: a named vector of coefficients\n\nresiduals: the residuals, that is response minus fitted values.\n\nfitted.values: the fitted mean values.\n\n    rank: the numeric rank of the fitted linear model.\n\n weights: (only for weighted fits) the specified weights.\n\ndf.residual: the residual degrees of freedom.\n\n    call: the matched call.\n\n   terms: the 'terms' object used.\n\ncontrasts: (only where relevant) the contrasts used.\n\n xlevels: (only where relevant) a record of the levels of the factors\n          used in fitting.\n\n  offset: the offset used (missing if none were used).\n\n       y: if requested, the response used.\n\n       x: if requested, the model matrix used.\n\n   model: if requested (the default), the model frame used.\n\nna.action: (where relevant) information returned by 'model.frame' on\n          the special handling of 'NA's.\n\n     In addition, non-null fits will have components 'assign',\n     'effects' and (unless not requested) 'qr' relating to the linear\n     fit, for use by extractor functions such as 'summary' and\n     'effects'.\n\nUsing time series:\n\n     Considerable care is needed when using 'lm' with time series.\n\n     Unless 'na.action = NULL', the time series attributes are stripped\n     from the variables before the regression is done.  (This is\n     necessary as omitting 'NA's would invalidate the time series\n     attributes, and if 'NA's are omitted in the middle of the series\n     the result would no longer be a regular time series.)\n\n     Even if the time series attributes are retained, they are not used\n     to line up series, so that the time shift of a lagged or\n     differenced regressor would be ignored.  It is good practice to\n     prepare a 'data' argument by 'ts.intersect(..., dframe = TRUE)',\n     then apply a suitable 'na.action' to that data frame and call 'lm'\n     with 'na.action = NULL' so that residuals and fitted values are\n     time series.\n\nAuthor(s):\n\n     The design was inspired by the S function of the same name\n     described in Chambers (1992).  The implementation of model formula\n     by Ross Ihaka was based on Wilkinson & Rogers (1973).\n\nReferences:\n\n     Chambers, J. M. (1992) _Linear models._ Chapter 4 of _Statistical\n     Models in S_ eds J. M. Chambers and T. J. Hastie, Wadsworth &\n     Brooks/Cole.\n\n     Wilkinson, G. N. and Rogers, C. E. (1973).  Symbolic descriptions\n     of factorial models for analysis of variance.  _Applied\n     Statistics_, *22*, 392-399.  doi:10.2307/2346786\n     <https://doi.org/10.2307/2346786>.\n\nSee Also:\n\n     'summary.lm' for more detailed summaries and 'anova.lm' for the\n     ANOVA table; 'aov' for a different interface.\n\n     The generic functions 'coef', 'effects', 'residuals', 'fitted',\n     'vcov'.\n\n     'predict.lm' (via 'predict') for prediction, including confidence\n     and prediction intervals; 'confint' for confidence intervals of\n     _parameters_.\n\n     'lm.influence' for regression diagnostics, and 'glm' for\n     *generalized* linear models.\n\n     The underlying low level functions, 'lm.fit' for plain, and\n     'lm.wfit' for weighted regression fitting.\n\n     More 'lm()' examples are available e.g., in 'anscombe',\n     'attitude', 'freeny', 'LifeCycleSavings', 'longley', 'stackloss',\n     'swiss'.\n\n     'biglm' in package 'biglm' for an alternative way to fit linear\n     models to large datasets (especially those with many cases).\n\nExamples:\n\n     require(graphics)\n     \n     ## Annette Dobson (1990) \"An Introduction to Generalized Linear Models\".\n     ## Page 9: Plant Weight Data.\n     ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)\n     trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)\n     group <- gl(2, 10, 20, labels = c(\"Ctl\",\"Trt\"))\n     weight <- c(ctl, trt)\n     lm.D9 <- lm(weight ~ group)\n     lm.D90 <- lm(weight ~ group - 1) # omitting intercept\n     \n     anova(lm.D9)\n     summary(lm.D90)\n     \n     opar <- par(mfrow = c(2,2), oma = c(0, 0, 1.1, 0))\n     plot(lm.D9, las = 1)      # Residuals, Fitted, ...\n     par(opar)\n     \n     ### less simple examples in \"See Also\" above\n```\n\n\n:::\n:::\n\n\n\n\n## S3 help pages\n\n- Now you know enough to understand the help pages for S3 objects.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?summary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject Summaries\n\nDescription:\n\n     'summary' is a generic function used to produce result summaries\n     of the results of various model fitting functions.  The function\n     invokes particular 'methods' which depend on the 'class' of the\n     first argument.\n\nUsage:\n\n     summary(object, ...)\n     \n     ## Default S3 method:\n     summary(object, ..., digits, quantile.type = 7)\n     ## S3 method for class 'data.frame'\n     summary(object, maxsum = 7,\n            digits = max(3, getOption(\"digits\")-3), ...)\n     \n     ## S3 method for class 'factor'\n     summary(object, maxsum = 100, ...)\n     \n     ## S3 method for class 'matrix'\n     summary(object, ...)\n     \n     ## S3 method for class 'summaryDefault'\n     format(x, digits = max(3L, getOption(\"digits\") - 3L), zdigits = 4L, ...)\n      ## S3 method for class 'summaryDefault'\n     print(x, digits = max(3L, getOption(\"digits\") - 3L), zdigits = 4L, ...)\n     \nArguments:\n\n  object: an object for which a summary is desired.\n\n       x: a result of the _default_ method of 'summary()'.\n\n  maxsum: integer, indicating how many levels should be shown for\n          'factor's.\n\n  digits: integer (or 'NULL', see 'Details'), used for number\n          formatting with 'signif()' (for 'summary.default') or\n          'format()' (for 'summary.data.frame').  In 'summary.default',\n          if not specified (i.e., 'missing(.)'), 'signif()' will _not_\n          be called anymore (since R >= 3.4.0, where the default has\n          been changed to only round in the 'print' and 'format'\n          methods).\n\n zdigits: integer, typically positive to be used in the internal\n          'zapsmall(*, digits = digits + zdigits)' call.\n\nquantile.type: integer code used in 'quantile(*, type=quantile.type)'\n          for the default method.\n\n     ...: additional arguments affecting the summary produced.\n\nDetails:\n\n     For 'factor's, the frequency of the first 'maxsum - 1' most\n     frequent levels is shown, and the less frequent levels are\n     summarized in '\"(Others)\"' (resulting in at most 'maxsum'\n     frequencies).\n\n     The 'digits' argument may be 'NULL' for some methods specifying to\n     use the default value, e.g., for the '\"summaryDefault\"' 'format()'\n     method.\n\n     The functions 'summary.lm' and 'summary.glm' are examples of\n     particular methods which summarize the results produced by 'lm'\n     and 'glm'.\n\nValue:\n\n     The form of the value returned by 'summary' depends on the class\n     of its argument.  See the documentation of the particular methods\n     for details of what is produced by that method.\n\n     The default method returns an object of class 'c(\"summaryDefault\",\n     \"table\")' which has specialized 'format' and 'print' methods.  The\n     'factor' method returns an integer vector.\n\n     The matrix and data frame methods return a matrix of class\n     '\"table\"', obtained by applying 'summary' to each column and\n     collating the results.\n\nReferences:\n\n     Chambers, J. M. and Hastie, T. J. (1992) _Statistical Models in\n     S_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'anova', 'summary.glm', 'summary.lm'.\n\nExamples:\n\n     summary(attenu, digits = 4) #-> summary.data.frame(...), default precision\n     summary(attenu $ station, maxsum = 20) #-> summary.factor(...)\n     \n     lst <- unclass(attenu$station) > 20 # logical with NAs\n     ## summary.default() for logicals -- different from *.factor:\n     summary(lst)\n     summary(as.factor(lst))\n     \n     ## show the effect of zdigits for skewed data\n     set.seed(17); x <- rlnorm(100, sdlog=2)\n     dput(sx <- summary(x))\n     sx # exponential format for this data\n     print(sx, zdigits = 3) # fixed point: \"more readable\"\n```\n\n\n:::\n:::\n\n\n\n\n## Finding classes and finding methods\n\n- Use the `methods()` function to find all methods that are available for a specific generic function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] summary,ANY-method                  summary,diagonalMatrix-method      \n [3] summary,sparseMatrix-method         summary.allFit*                    \n [5] summary.aov                         summary.aovlist*                   \n [7] summary.aspell*                     summary.check_packages_in_dir*     \n [9] summary.connection                  summary.corAR1*                    \n[11] summary.corARMA*                    summary.corCAR1*                   \n[13] summary.corCompSymm*                summary.corExp*                    \n[15] summary.corGaus*                    summary.corIdent*                  \n[17] summary.corLin*                     summary.corNatural*                \n[19] summary.corRatio*                   summary.corSpher*                  \n[21] summary.corStruct*                  summary.corSymm*                   \n[23] summary.data.frame                  summary.Date                       \n[25] summary.default                     summary.difftime                   \n[27] summary.ecdf*                       summary.factor                     \n[29] summary.glm                         summary.gls*                       \n[31] summary.infl*                       summary.lm                         \n[33] summary.lme*                        summary.lmList*                    \n[35] summary.lmList4*                    summary.loess*                     \n[37] summary.loglm*                      summary.manova                     \n[39] summary.matrix                      summary.merMod*                    \n[41] summary.mlm*                        summary.modelStruct*               \n[43] summary.negbin*                     summary.nls*                       \n[45] summary.nlsList*                    summary.packageStatus*             \n[47] summary.pdBlocked*                  summary.pdCompSymm*                \n[49] summary.pdDiag*                     summary.pdIdent*                   \n[51] summary.pdLogChol*                  summary.pdMat*                     \n[53] summary.pdNatural*                  summary.pdSymm*                    \n[55] summary.polr*                       summary.POSIXct                    \n[57] summary.POSIXlt                     summary.ppr*                       \n[59] summary.prcomp*                     summary.prcomplist*                \n[61] summary.princomp*                   summary.proc_time                  \n[63] summary.reStruct*                   summary.rlang:::list_of_conditions*\n[65] summary.rlang_error*                summary.rlang_message*             \n[67] summary.rlang_trace*                summary.rlang_warning*             \n[69] summary.rlm*                        summary.shingle*                   \n[71] summary.srcfile                     summary.srcref                     \n[73] summary.stepfun                     summary.stl*                       \n[75] summary.summary.merMod*             summary.table                      \n[77] summary.trellis*                    summary.tukeysmooth*               \n[79] summary.varComb*                    summary.varConstPower*             \n[81] summary.varConstProp*               summary.varExp*                    \n[83] summary.varFixed*                   summary.varFunc*                   \n[85] summary.varIdent*                   summary.varPower*                  \n[87] summary.warnings                   \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- Also use the `methods(class = ...)` function to find all methods that are available for a specific class.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = \"lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] add1           alias          anova          case.names     coerce        \n [6] confint        cooks.distance deviance       dfbeta         dfbetas       \n[11] drop1          dummy.coef     effects        extractAIC     family        \n[16] formula        hatvalues      influence      initialize     kappa         \n[21] labels         logLik         model.frame    model.matrix   nobs          \n[26] plot           predict        print          proj           qqnorm        \n[31] qr             residuals      rstandard      rstudent       show          \n[36] simulate       slotsFromS3    summary        variable.names vcov          \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- You can use a dot (`.`) to reference specific methods, not just generics.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?summary.lm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSummarizing Linear Model Fits\n\nDescription:\n\n     'summary' method for class '\"lm\"'.\n\nUsage:\n\n     ## S3 method for class 'lm'\n     summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)\n     \n     ## S3 method for class 'summary.lm'\n     print(x, digits = max(3, getOption(\"digits\") - 3),\n           symbolic.cor = x$symbolic.cor,\n           signif.stars = getOption(\"show.signif.stars\"), ...)\n     \nArguments:\n\n  object: an object of class '\"lm\"', usually, a result of a call to\n          'lm'.\n\n       x: an object of class '\"summary.lm\"', usually, a result of a\n          call to 'summary.lm'.\n\ncorrelation: logical; if 'TRUE', the correlation matrix of the\n          estimated parameters is returned and printed.\n\n  digits: the number of significant digits to use when printing.\n\nsymbolic.cor: logical. If 'TRUE', print the correlations in a symbolic\n          form (see 'symnum') rather than as numbers.\n\nsignif.stars: logical. If 'TRUE', 'significance stars' are printed for\n          each coefficient.\n\n     ...: further arguments passed to or from other methods.\n\nDetails:\n\n     'print.summary.lm' tries to be smart about formatting the\n     coefficients, standard errors, etc. and additionally gives\n     'significance stars' if 'signif.stars' is 'TRUE'.\n\n     Aliased coefficients are omitted in the returned object but\n     restored by the 'print' method.\n\n     Correlations are printed to two decimal places (or symbolically):\n     to see the actual correlations print 'summary(object)$correlation'\n     directly.\n\nValue:\n\n     The function 'summary.lm' computes and returns a list of summary\n     statistics of the fitted linear model given in 'object', using the\n     components (list elements) '\"call\"' and '\"terms\"' from its\n     argument, plus\n\nresiduals: the _weighted_ residuals, the usual residuals rescaled by\n          the square root of the weights specified in the call to 'lm'.\n\ncoefficients: a p x 4 matrix with columns for the estimated\n          coefficient, its standard error, t-statistic and\n          corresponding (two-sided) p-value.  Aliased coefficients are\n          omitted.\n\n aliased: named logical vector showing if the original coefficients are\n          aliased.\n\n   sigma: the square root of the estimated variance of the random error\n\n                       sigma^2 = 1/(n-p) Sum(w[i] R[i]^2),              \n          \n          where R[i] is the i-th residual, 'residuals[i]'.\n\n      df: degrees of freedom, a 3-vector (p, n-p, p*), the first being\n          the number of non-aliased coefficients, the last being the\n          total number of coefficients.\n\nfstatistic: (for models including non-intercept terms) a 3-vector with\n          the value of the F-statistic with its numerator and\n          denominator degrees of freedom.\n\nr.squared: R^2, the 'fraction of variance explained by the model',\n\n                    R^2 = 1 - Sum(R[i]^2) / Sum((y[i]- y*)^2),          \n          \n          where y* is the mean of y[i] if there is an intercept and\n          zero otherwise.\n\nadj.r.squared: the above R^2 statistic '_adjusted_', penalizing for\n          higher p.\n\ncov.unscaled: a p x p matrix of (unscaled) covariances of the coef[j],\n          j=1, ..., p.\n\ncorrelation: the correlation matrix corresponding to the above\n          'cov.unscaled', if 'correlation = TRUE' is specified.\n\nsymbolic.cor: (only if 'correlation' is true.)  The value of the\n          argument 'symbolic.cor'.\n\nna.action: from 'object', if present there.\n\nSee Also:\n\n     The model fitting function 'lm', 'summary'.\n\n     Function 'coef' will extract the matrix of coefficients with\n     standard errors, t-statistics and p-values.\n\nExamples:\n\n     ##-- Continuing the  lm(.) example:\n     coef(lm.D90)  # the bare coefficients\n     sld90 <- summary(lm.D90 <- lm(weight ~ group -1))  # omitting intercept\n     sld90\n     coef(sld90)  # much more\n     \n     ## model with *aliased* coefficient:\n     lm.D9. <- lm(weight ~ group + I(group != \"Ctl\"))\n     Sm.D9. <- summary(lm.D9.)\n     Sm.D9. #  shows the NA NA NA NA  line\n     stopifnot(length(cc <- coef(lm.D9.)) == 3, is.na(cc[3]),\n               dim(coef(Sm.D9.)) == c(2,4), Sm.D9.$df == c(2, 18, 3))\n```\n\n\n:::\n:::\n\n\n\n\n\n# Part 2: Formulas / Formulae\n\n## Utility of S3 methods {.scrollable}\n\n- Hopefully you can now see why understanding S3 methods is important.\n- But if you aren't convinced, maybe `formula` objects can convince you. Look how many methods there are!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = \"formula\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] [             aggregate     alias         all.equal     ansari.test  \n [6] barplot       bartlett.test boxplot       cdplot        coerce       \n[11] cor.test      deriv         deriv3        fligner.test  formula      \n[16] friedman.test ftable        getInitial    head          initialize   \n[21] kruskal.test  ks.test       lines         mood.test     mosaicplot   \n[26] pairs         plot          points        ppr           prcomp       \n[31] princomp      print         quade.test    selfStart     show         \n[36] simulate      slotsFromS3   spineplot     stripchart    sunflowerplot\n[41] t.test        terms         text          update        var.test     \n[46] wilcox.test  \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- And that doesn't include functions like `lm()` which ONLY have methods for formulas, not generics.\n\n## Formula example {.scrollable}\n\n- Say you want to get the correlation between MCV1 coverage rate and measles cases in Pakistan. You can call the `cor.test()` function by passing two vectors.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeas <- readr::read_rds(here::here(\"data\", \"measles_final.Rds\"))\n\ncor.test(\n\tx = meas$MCV1_coverage[meas$iso3c == \"PAK\"],\n\ty = meas$measles_cases[meas$iso3c == \"PAK\"]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tPearson's product-moment correlation\n\ndata:  meas$MCV1_coverage[meas$iso3c == \"PAK\"] and meas$measles_cases[meas$iso3c == \"PAK\"]\nt = -3.2036, df = 41, p-value = 0.002627\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.6591955 -0.1699300\nsample estimates:\n       cor \n-0.4474377 \n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- But if we inspect the methods for `cor.test`, we see it is an S3 generic with a method for `formula` class objects.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(cor.test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] cor.test.default* cor.test.formula*\nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- Typing in the code is easier, and reading the output is easier.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor.test(\n\t~ measles_cases + MCV1_coverage,\n\tdata = subset(meas, iso3c == \"PAK\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tPearson's product-moment correlation\n\ndata:  measles_cases and MCV1_coverage\nt = -3.2036, df = 41, p-value = 0.002627\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.6591955 -0.1699300\nsample estimates:\n       cor \n-0.4474377 \n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- But it pays to understand S3, because in certain circumstances, using the default method is easier!\n\n## Writing formulas {.incremental}\n\n- The formula language is a smaller language inside of R used for writing statistical models, and the full details [are in the `?formula` documentation](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/formula.html).\n- This little formula language is so useful it is now used in many textbooks and other languages (Python and Julia).\n- The basic syntax is `dv ~ iv1 + iv2 + ...`.\n- Recall that in `cor.test()` our formula didn't have a LHS -- there is no dependent variable in correlation.\n\n## You try it! {.scrollable}\n\n- Before, we saw that `boxplot` had a formula method. Use `boxplot()` with a formula to make boxplots of measles cases in 2002 for each `region` in the dataset.\n\n. . .\n\n- Hint: your code should look like this for the correct DV and IV.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(dv ~ iv, data = subset(meas, year == 2002))\n```\n:::\n\n\n\n\n. . .\n\n- Solution:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(measles_cases ~ region, data = subset(meas, year == 2002))\n```\n\n::: {.cell-output-display}\n![](Module06-S3-lm-formulas_files/figure-revealjs/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n\n\n\n\n## You try it (more advanced) {.scrollable}\n\n- Load the QCRC dataset, you only need the sheet \"Main_Dataset\" for this.\n- Fit a logistic regression model with 30 day mortality (`30D_Mortality` in the spreadsheet) as the outcome. Include any continuous or categorical predictors you want, we recommend avoiding variables that are (supposed to be) date/times.\n- Use appropriate S3 generic functions to get statistics about your model that you would want to report.\n\n. . .\n\n- Hint: to read in the data, do this.\n- Hint: you might need to do some data cleaning, because missing data are written as a period in the spreadsheet.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqcrc <- readxl::read_xlsx(\n\there::here(\"data\", \"QCRC_FINAL_Deidentified.xlsx\"),\n\tsheet = \"Main_Dataset\"\n)\n```\n:::\n\n\n\n\n. . .\n\n- Hint: your logistic regression code should look like this.\n- Hint: you need to put backticks (this thing: \\`, NOT an apostrophe. It's made by the ~ key on american keyboards.) around the name of the variable \\`30D_Mortality\\`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_30dm <- glm(\n\tsomething ~ something + something + ...,\n\tdata = qcrc,\n\tfamily = \"binomial\"\n)\n```\n:::\n\n\n\n\n. . .\n\n- Hint: some useful functions with methods for `glm`-class objects are `summary`, `coef`, and `confint`. (You probably also need the function `exp`!)\n\n. . .\n\n- One solution, you could have used any predictors you want, though you should be able to explain why they might affect 30 Day mortality.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A little cleaning for D Dimer\n# First turn the \".\" into actual NA's and make it a real number\nqcrc$d_dimer <- as.numeric(dplyr::na_if(qcrc$`D dimer`, \".\"))\n# Take the log cause it's skewed and positive\nqcrc$d_dimer <- log(qcrc$d_dimer)\n# Impute missing values with the median -- there are much better ways to do this\nmed_d_dimer <- median(qcrc$d_dimer, na.rm = FALSE)\nqcrc$d_dimer <- ifelse(is.na(qcrc$d_dimer), med_d_dimer, qcrc$d_dimer)\n\n# A little cleaning for Race\nqcrc$Race <- factor(qcrc$Race) |>\n\t# Make White the reference level\n\trelevel(ref = \"Caucasian or White\") |>\n\t# Groups other than \"Causian or White\" and \"Black or African American\" are\n\t# really small and heterogeneous so put them together\n\t# Not ideal but sometimes the best we can do\n\tforcats::fct_lump_n(n = 2)\n\n# Fit a model that controls for treatment, d_dimer, and race/ethnicity\nmodel_30dm <- glm(\n\t`30D_Mortality` ~ Remdesivir_or_placebo + d_dimer + Race,\n\tdata = qcrc,\n\tfamily = \"binomial\"\n)\n```\n:::\n\n\n\n\n. . .\n\n- Look at a lot of useful information with `summary()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(model_30dm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = `30D_Mortality` ~ Remdesivir_or_placebo + d_dimer + \n    Race, family = \"binomial\", data = qcrc)\n\nCoefficients:\n                               Estimate Std. Error z value Pr(>|z|)   \n(Intercept)                     -2.4352     0.8190  -2.973  0.00295 **\nRemdesivir_or_placebo           -0.7004     0.4105  -1.706  0.08793 . \nd_dimer                          0.1848     0.1015   1.820  0.06871 . \nRaceAfrican American  or Black   0.2738     0.3899   0.702  0.48260   \nRaceOther                        0.7733     0.4990   1.550  0.12119   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 317.14  on 256  degrees of freedom\nResidual deviance: 308.52  on 252  degrees of freedom\n  (31 observations deleted due to missingness)\nAIC: 318.52\n\nNumber of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- Get the OR's with `coef()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(model_30dm) |>\n\texp() |>\n\tround(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   (Intercept)          Remdesivir_or_placebo \n                          0.09                           0.50 \n                       d_dimer RaceAfrican American  or Black \n                          1.20                           1.31 \n                     RaceOther \n                          2.17 \n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- Get the profile CI's with `confint()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfint(model_30dm) |>\n\texp() |>\n\tround(2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWaiting for profiling to be done...\n```\n\n\n:::\n\n::: {.cell-output-display}\n\n\n|                               | 2.5 %| 97.5 %|\n|:------------------------------|-----:|------:|\n|(Intercept)                    |  0.02|   0.43|\n|Remdesivir_or_placebo          |  0.21|   1.07|\n|d_dimer                        |  0.99|   1.47|\n|RaceAfrican American  or Black |  0.63|   2.93|\n|RaceOther                      |  0.82|   5.86|\n:::\n:::\n\n\n\n\n. . .\n\n- A basic interpretation of the coefficient for `Remdesivir_or_placebo` (coded as 1 for remdesivir and 0 for placebo) might be \"Odds of mortality after 30 days in the remdesivisir group were 0.48 times the odds in the placebo group, for patients with the same D dimer level and race/ethnicity. The 95% CI for the odds ratio was 0.20 to 1.04. The effect was not significant at the $\\alpha = 0.05$ significance group, but is suggestive that at least some patients benefitted from remdesivir treatment.\"\n\n## Summary\n\n- We learned the basics of \"functional OOP\" and specifically R's S3 system, including how to check classes and find S3 methods for a class or classes for an S3 method.\n- We learned the basics of R formulas, a consistent and powerful sub-language in R for writing statistical models.\n- There's a lot more to formulas, but we'll discuss them more in a separate module based on interest/time.\n- If you want to read more about S3 or OOP in R, check out [the OOP section in Wickham's Advanced R](https://adv-r.hadley.nz/oo.html).\n",
    "supporting": [
      "Module06-S3-lm-formulas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}