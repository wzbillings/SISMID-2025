{
  "hash": "33cf5e6a5efc31d0c29a149e4b34d166",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 2: Functions\"\nformat: \n  revealjs:\n    scrollable: true\n    smaller: true\n    toc: false\n---\n\n\n\n## Learning Objectives\n\nAfter module 2, you should be able to...\n\n-   Describe and execute functions in R\n-   Modify default behavior of functions using arguments in R\n-   Use R-specific sources of help to get more information about functions and packages \n-   Differentiate between Base R functions and functions that come from other packages\n\n\n## Function - Basic term\n\n**Function** - Functions are \"self contained\" modules of code that **accomplish specific tasks**. Functions usually take in some sort of object (e.g., vector, list), process it, and return a result. You can write your own, use functions that come directly from installing R (i.e., Base R functions), or use functions from external packages.\n\nA function might help you add numbers together, create a plot, or organize your data. In fact, we have already used three functions in the Module 1, including `c()`, `matrix()`, `list()`. Here is another one, `sum()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 20234)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20235\n```\n\n\n:::\n:::\n\n\n\n\n## Function\n\nThe general usage for a function is the name of the function followed by parentheses (i.e., the function signature). Within the parentheses are **arguments**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name(argument1, argument2, ...)\n```\n:::\n\n\n\n\n## Arguments - Basic term\n\n**Arguments** are what you pass to the function and can include:\n\n1.  the physical object on which the function carries out a task (e.g., can be data such as a number 1 or 20234)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(1, 20234)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20235\n```\n\n\n:::\n:::\n\n\n\n2.  options that alter the way the function operates (e.g., such as the `base` argument in the function `log()`)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10, base = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(10, base = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(10, base=exp(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.302585\n```\n\n\n:::\n:::\n\n\n\n## Arguments\n\nMost functions are created with **default argument options**. The defaults represent standard values that the author of the function specified as being \"good enough in standard cases\". This means if you don't specify an argument when calling the function, it will use a default.\n\n-   If you want something specific, simply change the argument yourself with a value of your choice.\n-   If an argument is required but you did not specify it and there is no default argument specified when the function was created, you will receive an error.\n\n## Example\n\nWhat is the default in the `base` argument of the `log()` function?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.302585\n```\n\n\n:::\n:::\n\n\n\n## Sure that is easy enough, but how do you know\n\n- the purpose of a function? \n- what arguments a function includes? \n- how to specify the arguments?\n\n## Seeking help for using functions (*)\n\nThe best way of finding out this information is to use the `?` followed by the name of the function. Doing this will open up the help manual in the bottom RStudio Help panel. It provides a description of the function, usage, arguments, details, and examples. Lets look at the help file for the function `round()`\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/help_file.png){width=70%}\n:::\n:::\n\n\n\n\n## How to specify arguments\n\n1.  Arguments are separated with a comma\n2.  You can specify arguments by either including them in the correct order OR by assigning the argument within the function parentheses.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/log_args.png){width=70%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(base=2, x=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(x=10, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(10, base=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.321928\n```\n\n\n:::\n:::\n\n\n\n## Package - Basic term\n\nWhen you download R, it has a \"base\" set of functions, that are associated with a \"base\" set of packages including: 'base', 'datasets', 'graphics', 'grDevices', 'methods', 'stats' (typically just referred to as **Base R**).\n\n-   e.g., the `log()` function comes from the 'base' package\n\n**Package** - a package in R is a bundle or \"package\" of code (and or possibly data) that can be loaded together for easy repeated use or for **sharing** with others.\n\nPackages are analogous to software applications like Microsoft Word. After installation, your operating system allows you to use it, just like having Word installed allows you to use it.\n\n## Packages\n\nThe Packages pane in RStudio can help you identify what have been installed (listed), and which one have been attached (check mark).\n\nLets go look at the Packages pane, find the `base` package and find the `log()` function. It automatically loads the help file that we looked at earlier using `?log`.\n\n\n## Additional Packages\n\nYou can install additional packages for your use from [CRAN](https://cran.r-project.org/) or [GitHub](https://github.com/). These additional packages are written by RStudio or R users/developers (like us)\n\n-   Not all packages available on CRAN or GitHub are trustworthy\n-   RStudio (the company) makes a lot of great packages\n-   Who wrote it? **Hadley Wickham** is a major authority on R (Employee and Developer at RStudio)\n-   How to [trust](https://simplystatistics.org/posts/2015-11-06-how-i-decide-when-to-trust-an-r-package/#:~:text=The%20first%20thing%20I%20do,I%20immediately%20trust%20the%20package.) an R package\n\n## **Installing** and attaching packages\n\nTo use the bundle or \"package\" of code (and or possibly data) from a package, you need to install and also attach the package.\n\nTo install a package you can \n\n1. go to R Studio Menu Bar Tools Menu ---\\> Install Packages in the RStudio header\n\nOR\n\n2. use the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"package_name\")\n```\n:::\n\n\n\n\n## Installing and **attaching** packages\n\nTo attach (i.e., be able to use the package) you can use the following code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(package_name) #library(package_name) also works\n```\n:::\n\n\n\nMore on installing and attaching packages later...\n\n\n## Mini exercise\n\nFind and execute a **Base R** function that will round the number 0.86424 to two digits.\n\n\n## Functions from Module 1\n\nThe combine function `c()` concatenate/collects/combines single R objects into a vector of R objects. It is mostly used for creating vectors of numbers, character strings, and other data types. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?c\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCombine Values into a Vector or List\n\nDescription:\n\n     This is a generic function which combines its arguments.\n\n     The default method combines its arguments to form a vector.  All\n     arguments are coerced to a common type which is the type of the\n     returned value, and all attributes except names are removed.\n\nUsage:\n\n     ## S3 Generic function\n     c(...)\n     \n     ## Default S3 method:\n     c(..., recursive = FALSE, use.names = TRUE)\n     \nArguments:\n\n     ...: objects to be concatenated.  All 'NULL' entries are dropped\n          before method dispatch unless at the very beginning of the\n          argument list.\n\nrecursive: logical.  If 'recursive = TRUE', the function recursively\n          descends through lists (and pairlists) combining all their\n          elements into a vector.\n\nuse.names: logical indicating if 'names' should be preserved.\n\nDetails:\n\n     The output type is determined from the highest type of the\n     components in the hierarchy NULL < raw < logical < integer <\n     double < complex < character < list < expression.  Pairlists are\n     treated as lists, whereas non-vector components (such as 'name's /\n     'symbol's and 'call's) are treated as one-element 'list's which\n     cannot be unlisted even if 'recursive = TRUE'.\n\n     There is a 'c.factor' method which combines factors into a factor.\n\n     'c' is sometimes used for its side effect of removing attributes\n     except names, for example to turn an 'array' into a vector.\n     'as.vector' is a more intuitive way to do this, but also drops\n     names.  Note that methods other than the default are not required\n     to do this (and they will almost certainly preserve a class\n     attribute).\n\n     This is a primitive function.\n\nValue:\n\n     'NULL' or an expression or a vector of an appropriate mode.  (With\n     no arguments the value is 'NULL'.)\n\nS4 methods:\n\n     This function is S4 generic, but with argument list '(x, ...)'.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'unlist' and 'as.vector' to produce attribute-free vectors.\n\nExamples:\n\n     c(1,7:9)\n     c(1:5, 10.5, \"next\")\n     \n     ## uses with a single argument to drop attributes\n     x <- 1:4\n     names(x) <- letters[1:4]\n     x\n     c(x)          # has names\n     as.vector(x)  # no names\n     dim(x) <- c(2,2)\n     x\n     c(x)\n     as.vector(x)\n     \n     ## append to a list:\n     ll <- list(A = 1, c = \"C\")\n     ## do *not* use\n     c(ll, d = 1:3) # which is == c(ll, as.list(c(d = 1:3)))\n     ## but rather\n     c(ll, d = list(1:3))  # c() combining two lists\n     \n     c(list(A = c(B = 1)), recursive = TRUE)\n     \n     c(options(), recursive = TRUE)\n     c(list(A = c(B = 1, C = 2), B = c(E = 7)), recursive = TRUE)\n```\n\n\n:::\n:::\n\n\n\n## Functions from Module 1\n\nThe `paste0()` function concatenate/combines vectors after converting to character.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvector.object2 <- paste0(c(\"b\", \"t\", \"u\"), c(8,4,2))\nvector.object2\n?paste0\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nConcatenate Strings\n\nDescription:\n\n     Concatenate vectors after converting to character.\n\nUsage:\n\n     paste (..., sep = \" \", collapse = NULL, recycle0 = FALSE)\n     paste0(...,            collapse = NULL, recycle0 = FALSE)\n     \nArguments:\n\n     ...: one or more R objects, to be converted to character vectors.\n\n     sep: a character string to separate the terms.  Not\n          'NA_character_'.\n\ncollapse: an optional character string to separate the results.  Not\n          'NA_character_'.\n\nrecycle0: 'logical' indicating if zero-length character arguments\n          should lead to the zero-length 'character(0)' after the\n          'sep'-phase (which turns into '\"\"' in the 'collapse'-phase,\n          i.e., when 'collapse' is not 'NULL').\n\nDetails:\n\n     'paste' converts its arguments (_via_ 'as.character') to character\n     strings, and concatenates them (separating them by the string\n     given by 'sep').  If the arguments are vectors, they are\n     concatenated term-by-term to give a character vector result.\n     Vector arguments are recycled as needed, with zero-length\n     arguments being recycled to '\"\"' only if 'recycle0' is not true\n     _or_ 'collapse' is not 'NULL'.\n\n     Note that 'paste()' coerces 'NA_character_', the character missing\n     value, to '\"NA\"' which may seem undesirable, e.g., when pasting\n     two character vectors, or very desirable, e.g. in 'paste(\"the\n     value of p is \", p)'.\n\n     'paste0(..., collapse)' is equivalent to 'paste(..., sep = \"\",\n     collapse)', slightly more efficiently.\n\n     If a value is specified for 'collapse', the values in the result\n     are then concatenated into a single string, with the elements\n     being separated by the value of 'collapse'.\n\nValue:\n\n     A character vector of the concatenated values.  This will be of\n     length zero if all the objects are, unless 'collapse' is non-NULL,\n     in which case it is '\"\"' (a single empty string).\n\n     If any input into an element of the result is in UTF-8 (and none\n     are declared with encoding '\"bytes\"', see 'Encoding'), that\n     element will be in UTF-8, otherwise in the current encoding in\n     which case the encoding of the element is declared if the current\n     locale is either Latin-1 or UTF-8, at least one of the\n     corresponding inputs (including separators) had a declared\n     encoding and all inputs were either ASCII or declared.\n\n     If an input into an element is declared with encoding '\"bytes\"',\n     no translation will be done of any of the elements and the\n     resulting element will have encoding '\"bytes\"'.  If 'collapse' is\n     non-NULL, this applies also to the second, collapsing, phase, but\n     some translation may have been done in pasting object together in\n     the first phase.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'toString' typically calls 'paste(*, collapse=\", \")'.  String\n     manipulation with 'as.character', 'substr', 'nchar', 'strsplit';\n     further, 'cat' which concatenates and writes to a file, and\n     'sprintf' for C like string construction.\n\n     'plotmath' for the use of 'paste' in plot annotation.\n\nExamples:\n\n     ## When passing a single vector, paste0 and paste work like as.character.\n     paste0(1:12)\n     paste(1:12)        # same\n     as.character(1:12) # same\n     \n     ## If you pass several vectors to paste0, they are concatenated in a\n     ## vectorized way.\n     (nth <- paste0(1:12, c(\"st\", \"nd\", \"rd\", rep(\"th\", 9))))\n     \n     ## paste works the same, but separates each input with a space.\n     ## Notice that the recycling rules make every input as long as the longest input.\n     paste(month.abb, \"is the\", nth, \"month of the year.\")\n     paste(month.abb, letters)\n     \n     ## You can change the separator by passing a sep argument\n     ## which can be multiple characters.\n     paste(month.abb, \"is the\", nth, \"month of the year.\", sep = \"_*_\")\n     \n     ## To collapse the output into a single string, pass a collapse argument.\n     paste0(nth, collapse = \", \")\n     \n     ## For inputs of length 1, use the sep argument rather than collapse\n     paste(\"1st\", \"2nd\", \"3rd\", collapse = \", \") # probably not what you wanted\n     paste(\"1st\", \"2nd\", \"3rd\", sep = \", \")\n     \n     ## You can combine the sep and collapse arguments together.\n     paste(month.abb, nth, sep = \": \", collapse = \"; \")\n     \n     ## Using paste() in combination with strwrap() can be useful\n     ## for dealing with long strings.\n     (title <- paste(strwrap(\n         \"Stopping distance of cars (ft) vs. speed (mph) from Ezekiel (1930)\",\n         width = 30), collapse = \"\\n\"))\n     plot(dist ~ speed, cars, main = title)\n     \n     ## 'recycle0 = TRUE' allows more vectorized behaviour, i.e. zero-length recycling :\n     valid <- FALSE\n     val <- pi\n     paste(\"The value is\", val[valid], \"-- not so good!\")\n     paste(\"The value is\", val[valid], \"-- good: empty!\", recycle0=TRUE) # -> character(0)\n     ## When  'collapse = <string>',  the result is a length-1 string :\n     paste(\"foo\", {}, \"bar\", collapse=\"|\")                  # |-->  \"foo  bar\"\n     paste(\"foo\", {}, \"bar\", collapse=\"|\", recycle0 = TRUE) # |-->  \"\"\n     ## all empty args\n     paste(    collapse=\"|\")                  # |-->  \"\"  as do all these:\n     paste(    collapse=\"|\", recycle0 = TRUE)\n     paste({}, collapse=\"|\")\n     paste({}, collapse=\"|\", recycle0 = TRUE)\n```\n\n\n:::\n:::\n\n\n\n\n\n## Functions from Module 1\n\nThe `matrix()` function creates a matrix from the given set of values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix.object <- matrix(data=vector.object1, nrow=2, ncol=2, byrow=TRUE)\nmatrix.object\n?matrix\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nMatrices\n\nDescription:\n\n     'matrix' creates a matrix from the given set of values.\n\n     'as.matrix' attempts to turn its argument into a matrix.\n\n     'is.matrix' tests if its argument is a (strict) matrix.\n\nUsage:\n\n     matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,\n            dimnames = NULL)\n     \n     as.matrix(x, ...)\n     ## S3 method for class 'data.frame'\n     as.matrix(x, rownames.force = NA, ...)\n     \n     is.matrix(x)\n     \nArguments:\n\n    data: an optional data vector (including a list or 'expression'\n          vector).  Non-atomic classed R objects are coerced by\n          'as.vector' and all attributes discarded.\n\n    nrow: the desired number of rows.\n\n    ncol: the desired number of columns.\n\n   byrow: logical. If 'FALSE' (the default) the matrix is filled by\n          columns, otherwise the matrix is filled by rows.\n\ndimnames: A 'dimnames' attribute for the matrix: 'NULL' or a 'list' of\n          length 2 giving the row and column names respectively.  An\n          empty list is treated as 'NULL', and a list of length one as\n          row names.  The list can be named, and the list names will be\n          used as names for the dimensions.\n\n       x: an R object.\n\n     ...: additional arguments to be passed to or from methods.\n\nrownames.force: logical indicating if the resulting matrix should have\n          character (rather than 'NULL') 'rownames'.  The default,\n          'NA', uses 'NULL' rownames if the data frame has 'automatic'\n          row.names or for a zero-row data frame.\n\nDetails:\n\n     If one of 'nrow' or 'ncol' is not given, an attempt is made to\n     infer it from the length of 'data' and the other parameter.  If\n     neither is given, a one-column matrix is returned.\n\n     If there are too few elements in 'data' to fill the matrix, then\n     the elements in 'data' are recycled.  If 'data' has length zero,\n     'NA' of an appropriate type is used for atomic vectors ('0' for\n     raw vectors) and 'NULL' for lists.\n\n     'is.matrix' returns 'TRUE' if 'x' is a vector and has a '\"dim\"'\n     attribute of length 2 and 'FALSE' otherwise.  Note that a\n     'data.frame' is *not* a matrix by this test.  The function is\n     generic: you can write methods to handle specific classes of\n     objects, see InternalMethods.\n\n     'as.matrix' is a generic function.  The method for data frames\n     will return a character matrix if there is only atomic columns and\n     any non-(numeric/logical/complex) column, applying 'as.vector' to\n     factors and 'format' to other non-character columns.  Otherwise,\n     the usual coercion hierarchy (logical < integer < double <\n     complex) will be used, e.g., all-logical data frames will be\n     coerced to a logical matrix, mixed logical-integer will give a\n     integer matrix, etc.\n\n     The default method for 'as.matrix' calls 'as.vector(x)', and hence\n     e.g. coerces factors to character vectors.\n\n     When coercing a vector, it produces a one-column matrix, and\n     promotes the names (if any) of the vector to the rownames of the\n     matrix.\n\n     'is.matrix' is a primitive function.\n\n     The 'print' method for a matrix gives a rectangular layout with\n     dimnames or indices.  For a list matrix, the entries of length not\n     one are printed in the form 'integer,7' indicating the type and\n     length.\n\nNote:\n\n     If you just want to convert a vector to a matrix, something like\n\n       dim(x) <- c(nx, ny)\n       dimnames(x) <- list(row_names, col_names)\n     \n     will avoid duplicating 'x' _and_ preserve 'class(x)' which may be\n     useful, e.g., for 'Date' objects.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'data.matrix', which attempts to convert to a numeric matrix.\n\n     A matrix is the special case of a two-dimensional 'array'.\n     'inherits(m, \"array\")' is true for a 'matrix' 'm'.\n\nExamples:\n\n     is.matrix(as.matrix(1:10))\n     !is.matrix(warpbreaks)  # data.frame, NOT matrix!\n     warpbreaks[1:10,]\n     as.matrix(warpbreaks[1:10,])  # using as.matrix.data.frame(.) method\n     \n     ## Example of setting row and column names\n     mdat <- matrix(c(1,2,3, 11,12,13), nrow = 2, ncol = 3, byrow = TRUE,\n                    dimnames = list(c(\"row1\", \"row2\"),\n                                    c(\"C.1\", \"C.2\", \"C.3\")))\n     mdat\n```\n\n\n:::\n:::\n\n\n\n\n## Summary\n\n- Functions are \"self contained\" modules of code that accomplish specific tasks.\n- Arguments are what you pass to functions (e.g., objects on which you carry out the task or options for how to carry out the task)\n- Arguments may include defaults that the author of the function specified as being \"good enough in standard cases\", but that can be changed.\n- An R Package is a bundle or \"package\" of code (and or possibly data) that can be used by installing it once and attaching it (using `require`()`) each time R/Rstudio is opened\n- The Help pane in RStudio is useful for to get more information about functions and packages \n\n\n## Acknowledgements\n\nThese are the materials we looked through, modified, or extracted to complete this module's lecture.\n\n- [\"Introduction to R - ARCHIVED\" from  Harvard Chan Bioinformatics Core (HBC)](https://hbctraining.github.io/Intro-to-R/lessons/03_introR-functions-and-arguments.html#:\\~:text=A%20key%20feature%20of%20R,it%2C%20and%20return%20a%20result.)\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}