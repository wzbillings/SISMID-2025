{
  "hash": "12a353d15ef4018df2e7e11b0007bf59",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 13: Iteration in R\"\nformat:\n  revealjs:\n    toc: false\n---\n\n\n\n\n\n\n\n## Learning goals\n\n1. Replace repetitive code with a `for` loop\n1. Use vectorization to replace unnecessary loops\n\n## What is iteration?\n\n* Whenever you repeat something, that's iteration.\n* In `R`, this means running the same code multiple times in a row.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"penguins\", package = \"palmerpenguins\")\nfor (this_island in levels(penguins$island)) {\n\tisland_mean <-\n\t\tpenguins$bill_depth_mm[penguins$island == this_island] |>\n\t\tmean(na.rm = TRUE) |>\n\t\tround(digits = 2)\n\t\n\tcat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n\t\t\t\t\t\t\t\"mm.\\n\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.\n```\n\n\n:::\n:::\n\n\n\n\n## Parts of a loop\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1,9\"}\nfor (this_island in levels(penguins$island)) {\n\tisland_mean <-\n\t\tpenguins$bill_depth_mm[penguins$island == this_island] |>\n\t\tmean(na.rm = TRUE) |>\n\t\tround(digits = 2)\n\t\n\tcat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n\t\t\t\t\t\t\t\"mm.\\n\"))\n}\n```\n:::\n\n\n\n\nThe **header** declares how many times we will repeat the same code. The header\ncontains a **control variable** that changes in each repetition and a\n**sequence** of values for the control variable to take.\n\n## Parts of a loop\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-8\"}\nfor (this_island in levels(penguins$island)) {\n\tisland_mean <-\n\t\tpenguins$bill_depth_mm[penguins$island == this_island] |>\n\t\tmean(na.rm = TRUE) |>\n\t\tround(digits = 2)\n\t\n\tcat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n\t\t\t\t\t\t\t\"mm.\\n\"))\n}\n```\n:::\n\n\n\n\nThe **body** of the loop contains code that will be repeated a number of times\nbased on the header instructions. In `R`, the body has to be surrounded by\ncurly braces.\n\n## Header parts\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (this_island in levels(penguins$island)) {...}\n```\n:::\n\n\n\n\n* `for`: keyword that declares we are doing a for loop.\n* `(...)`: parentheses after `for` declare the control variable and sequence.\n* `this_island`: the control variable.\n* `in`: keyword that separates the control varibale and sequence.\n* `levels(penguins$island)`: the sequence.\n* `{}`: curly braces will contain the body code.\n\n## Header parts\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (this_island in levels(penguins$island)) {...}\n```\n:::\n\n\n\n\n* Since `levels(penguins$island)` evaluates to\n`c(\"Biscoe\", \"Dream\", \"Torgersen\")`, our loop will repeat 3 times.\n\n| Iteration | `this_island` |\n|-----------|---------------|\n| 1         | \"Biscoe\"      |\n| 2         | \"Dream\"       |\n| 3         | \"Torgersen\"   |\n\n* Everything inside of `{...}` will be repeated three times.\n\n## Loop iteration 1\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisland_mean <-\n\tpenguins$bill_depth_mm[penguins$island == \"Biscoe\"] |>\n\tmean(na.rm = TRUE) |>\n\tround(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Biscoe\", \"Island was\", island_mean,\n\t\t\t\t\t\"mm.\\n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe mean bill depth on Biscoe Island was 15.87 mm.\n```\n\n\n:::\n:::\n\n\n\n\n## Loop iteration 2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisland_mean <-\n\tpenguins$bill_depth_mm[penguins$island == \"Dream\"] |>\n\tmean(na.rm = TRUE) |>\n\tround(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Dream\", \"Island was\", island_mean,\n\t\t\t\t\t\"mm.\\n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe mean bill depth on Dream Island was 18.34 mm.\n```\n\n\n:::\n:::\n\n\n\n\n## Loop iteration 3\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisland_mean <-\n\tpenguins$bill_depth_mm[penguins$island == \"Torgersen\"] |>\n\tmean(na.rm = TRUE) |>\n\tround(digits = 2)\n\ncat(paste(\"The mean bill depth on\", \"Torgersen\", \"Island was\", island_mean,\n\t\t\t\t\t\"mm.\\n\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe mean bill depth on Torgersen Island was 18.43 mm.\n```\n\n\n:::\n:::\n\n\n\n\n## The loop structure automates this process for us so we don't have to copy and paste our code!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (this_island in levels(penguins$island)) {\n\tisland_mean <-\n\t\tpenguins$bill_depth_mm[penguins$island == this_island] |>\n\t\tmean(na.rm = TRUE) |>\n\t\tround(digits = 2)\n\t\n\tcat(paste(\"The mean bill depth on\", this_island, \"Island was\", island_mean,\n\t\t\t\t\t\t\t\"mm.\\n\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe mean bill depth on Biscoe Island was 15.87 mm.\nThe mean bill depth on Dream Island was 18.34 mm.\nThe mean bill depth on Torgersen Island was 18.43 mm.\n```\n\n\n:::\n:::\n\n\n\n\n## Side note: the pipe operator `|>` {.scrollable}\n\n* This operator allows us to chain commands together so the output of the\nprevious statement is passed into the next statement.\n* E.g. the code\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisland_mean <-\n\tpenguins$bill_depth_mm[penguins$island == \"Torgersen\"] |>\n\tmean(na.rm = TRUE) |>\n\tround(digits = 2)\n```\n:::\n\n\n\n\nwill be transformed by R into\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisland_mean <-\n\tround(\n\t\tmean(\n\t\t\tpenguins$bill_depth_mm[penguins$island == \"Torgersen\"],\n\t\t\tna.rm = TRUE\n\t\t),\n\t\tdigits = 2\n\t)\n```\n:::\n\n\n\n\nbefore it gets run. So using the pipe is a way to avoid deeply nested functions.\n\nNote that another alernative could be like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nisland_data <- penguins$bill_depth_mm[penguins$island == \"Torgersen\"]\nisland_mean_raw <- mean(island_data, na.rm = TRUE)\nisland_mean <- round(island_mean_raw, digits = 2)\n```\n:::\n\n\n\n\nSo using `|>` can also help us to avoid a lot of assignments.\n\n* **Whichever style you prefer is fine!** Some people like the pipe, some\npeople like nesting, and some people like intermediate assignments. All three\nare perfectly fine as long as your code is neat and commented.\n* If you go on to the `tidyverse` class, you will use a lot of piping -- it\nis a very popular coding style in R these days thanks to the inventors of\nthe `tidyverse` packages.\n* Also note that you need R version 4.1.0 or better to use `|>`. If you are\non an older version of R, it will not be available.\n\n**Now, back to loops!**\n\n## Remember: write DRY code!\n\n* DRY = \"Don't Repeat Yourself\"\n* Instead of copying and pasting, write loops and functions.\n* Easier to debug and change in the future!\n\n. . .\n\n* Of course, we all copy and paste code sometimes. If you are running on a\ntight deadline or can't get a loop or function to work, you might need to.\n**DRY code is good, but working code is best!**\n\n## {#tweet-slide data-menu-title=\"Hadley tweet\" .center}\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](../images/hadley-tweet.PNG)\n:::\n:::\n\n\n\n\n## You try it!\n\nWrite a loop that goes from 1 to 10, squares each of the numbers, and prints\nthe squared number.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n\tcat(i ^ 2, \"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 \n4 \n9 \n16 \n25 \n36 \n49 \n64 \n81 \n100 \n```\n\n\n:::\n:::\n\n\n\n\n## Wait, did we need to do that? {.incremental}\n\n* Well, yes, because you need to practice loops!\n* But technically no, because we can use **vectorization**.\n* Almost all basic operations in R are **vectorized**: they work on a vector of\narguments all at the same time.\n\n## Wait, did we need to do that? {.scrollable}\n\n* Well, yes, because you need to practice loops!\n* But technically no, because we can use **vectorization**.\n* Almost all basic operations in R are **vectorized**: they work on a vector of\narguments all at the same time.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# No loop needed!\n(1:10)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]   1   4   9  16  25  36  49  64  81 100\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the first 10 odd numbers, a common CS 101 loop problem on exams\n(1:20)[which((1:20 %% 2) == 1)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  3  5  7  9 11 13 15 17 19\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n* So you should really try vectorization first, then use loops only when\nyou can't use vectorization.\n\n## Loop walkthrough\n\n* Let's walk through a complex but useful example where we can't use\nvectorization.\n* Load the cleaned measles dataset, and subset it so you only have MCV1 records.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeas <- readRDS(here::here(\"data\", \"measles_final.Rds\")) |>\n\tsubset(vaccine_antigen == \"MCV1\")\nstr(meas)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t7972 obs. of  7 variables:\n $ iso3c           : chr  \"AFG\" \"AFG\" \"AFG\" \"AFG\" ...\n $ time            : int  1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 ...\n $ country         : chr  \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ Cases           : int  2792 5166 2900 640 353 2012 1511 638 1154 492 ...\n $ vaccine_antigen : chr  \"MCV1\" \"MCV1\" \"MCV1\" \"MCV1\" ...\n $ vaccine_coverage: int  11 NA 8 9 14 14 14 31 34 22 ...\n $ total_pop       : chr  \"12486631\" \"11155195\" \"10088289\" \"9951449\" ...\n```\n\n\n:::\n:::\n\n\n\n\n## Loop walkthrough\n\n* First, make an empty `list`. This is where we'll store our results. Make it\nthe same length as the number of countries in the dataset.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- vector(mode = \"list\", length = length(unique(meas$country)))\n```\n:::\n\n\n\n\n* This is called *preallocation* and it can make your loops much faster.\n\n## Loop walkthrough\n\n* Loop through every country in the dataset, and get the median, first and third\nquartiles, and range for each country. Store those summary statistics in a data frame.\n* What should the header look like?\n\n. . .\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountries <- unique(meas$country)\nfor (i in 1:length(countries)) {...}\n```\n:::\n\n\n\n\n. . .\n\n* Note that we use the **index** as the control variable. When you need to\ndo complex operations inside a loop, this is easier than the **for-each**\nconstruction we used earlier.\n\n## Loop walkthrough {.scrollable}\n\n* Now write out the body of the code. First we need to subset the data, to get\nonly the data for the current country.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:length(countries)) {\n\t# Get the data for the current country only\n\tcountry_data <- subset(meas, country == countries[i])\n}\n```\n:::\n\n\n\n\n. . .\n\n* Next we need to get the summary of the cases for that country.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:length(countries)) {\n\t# Get the data for the current country only\n\tcountry_data <- subset(meas, country == countries[i])\n\t\n\t# Get the summary statistics for this country\n\tcountry_cases <- country_data$Cases\n\tcountry_quart <- quantile(\n\t\tcountry_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n\t)\n\tcountry_range <- range(country_cases, na.rm = TRUE)\n}\n```\n:::\n\n\n\n\n. . .\n\n* Next we save the summary statistics into a data frame.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:length(countries)) {\n\t# Get the data for the current country only\n\tcountry_data <- subset(meas, country == countries[i])\n\t\n\t# Get the summary statistics for this country\n\tcountry_cases <- country_data$Cases\n\tcountry_quart <- quantile(\n\t\tcountry_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n\t)\n\tcountry_range <- range(country_cases, na.rm = TRUE)\n\t\n\t# Save the summary statistics into a data frame\n\tcountry_summary <- data.frame(\n\t\tcountry = countries[[i]],\n\t\tmin = country_range[[1]],\n\t\tQ1 = country_quart[[1]],\n\t\tmedian = country_quart[[2]],\n\t\tQ3 = country_quart[[3]],\n\t\tmax = country_range[[2]]\n\t)\n}\n```\n:::\n\n\n\n\n. . .\n\n* And finally, we save the data frame as the next element in our storage list.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:length(countries)) {\n\t# Get the data for the current country only\n\tcountry_data <- subset(meas, country == countries[i])\n\t\n\t# Get the summary statistics for this country\n\tcountry_cases <- country_data$Cases\n\tcountry_quart <- quantile(\n\t\tcountry_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n\t)\n\tcountry_range <- range(country_cases, na.rm = TRUE)\n\t\n\t# Save the summary statistics into a data frame\n\tcountry_summary <- data.frame(\n\t\tcountry = countries[[i]],\n\t\tmin = country_range[[1]],\n\t\tQ1 = country_quart[[1]],\n\t\tmedian = country_quart[[2]],\n\t\tQ3 = country_quart[[3]],\n\t\tmax = country_range[[2]]\n\t)\n\t\n\t# Save the results to our container\n\tres[[i]] <- country_summary\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x): no non-missing arguments to min; returning Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x): no non-missing arguments to max; returning -Inf\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n* Let's take a look at the results.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n      country min   Q1 median   Q3   max\n1 Afghanistan 353 1154   2205 5166 31107\n\n[[2]]\n  country min  Q1 median    Q3   max\n1  Angola  29 700   3271 14474 30067\n\n[[3]]\n  country min Q1 median Q3    max\n1 Albania   0  1     12 29 136034\n\n[[4]]\n  country min Q1 median Q3 max\n1 Andorra   0  0      1  2   5\n\n[[5]]\n               country min    Q1 median   Q3  max\n1 United Arab Emirates  22 89.75    320 1128 2913\n\n[[6]]\n    country min Q1 median     Q3   max\n1 Argentina   0  0     17 4591.5 42093\n```\n\n\n:::\n:::\n\n\n\n\n* How do we deal with this to get it into a nice form?\n\n. . .\n\n* We can use a *vectorization* trick: the function `do.call()` seems like\nancient computer science magic. And it is. But it will actually help us a\nlot.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres_df <- do.call(rbind, res)\nhead(res_df)\n```\n\n::: {.cell-output-display}\n\n\n|country              | min|      Q1| median|      Q3|    max|\n|:--------------------|---:|-------:|------:|-------:|------:|\n|Afghanistan          | 353| 1154.00|   2205|  5166.0|  31107|\n|Angola               |  29|  700.00|   3271| 14474.0|  30067|\n|Albania              |   0|    1.00|     12|    29.0| 136034|\n|Andorra              |   0|    0.00|      1|     2.0|      5|\n|United Arab Emirates |  22|   89.75|    320|  1128.0|   2913|\n|Argentina            |   0|    0.00|     17|  4591.5|  42093|\n:::\n:::\n\n\n\n\n* It combined our data frames together! Let's take a look at the `rbind` and\n`do.call()` help packages to see what happened.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?rbind\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCombine R Objects by Rows or Columns\n\nDescription:\n\n     Take a sequence of vector, matrix or data-frame arguments and\n     combine by _c_olumns or _r_ows, respectively.  These are generic\n     functions with methods for other R classes.\n\nUsage:\n\n     cbind(..., deparse.level = 1)\n     rbind(..., deparse.level = 1)\n     ## S3 method for class 'data.frame'\n     rbind(..., deparse.level = 1, make.row.names = TRUE,\n           stringsAsFactors = FALSE, factor.exclude = TRUE)\n     \nArguments:\n\n     ...: (generalized) vectors or matrices.  These can be given as\n          named arguments.  Other R objects may be coerced as\n          appropriate, or S4 methods may be used: see sections\n          'Details' and 'Value'.  (For the '\"data.frame\"' method of\n          'cbind' these can be further arguments to 'data.frame' such\n          as 'stringsAsFactors'.)\n\ndeparse.level: integer controlling the construction of labels in the\n          case of non-matrix-like arguments (for the default method):\n          'deparse.level = 0' constructs no labels;\n          the default 'deparse.level = 1' typically and 'deparse.level\n          = 2' always construct labels from the argument names, see the\n          'Value' section below.\n\nmake.row.names: (only for data frame method:) logical indicating if\n          unique and valid 'row.names' should be constructed from the\n          arguments.\n\nstringsAsFactors: logical, passed to 'as.data.frame'; only has an\n          effect when the '...' arguments contain a (non-'data.frame')\n          'character'.\n\nfactor.exclude: if the data frames contain factors, the default 'TRUE'\n          ensures that 'NA' levels of factors are kept, see PR#17562\n          and the 'Data frame methods'.  In R versions up to 3.6.x,\n          'factor.exclude = NA' has been implicitly hardcoded (R <=\n          3.6.0) or the default (R = 3.6.x, x >= 1).\n\nDetails:\n\n     The functions 'cbind' and 'rbind' are S3 generic, with methods for\n     data frames.  The data frame method will be used if at least one\n     argument is a data frame and the rest are vectors or matrices.\n     There can be other methods; in particular, there is one for time\n     series objects.  See the section on 'Dispatch' for how the method\n     to be used is selected.  If some of the arguments are of an S4\n     class, i.e., 'isS4(.)' is true, S4 methods are sought also, and\n     the hidden 'cbind' / 'rbind' functions from package 'methods'\n     maybe called, which in turn build on 'cbind2' or 'rbind2',\n     respectively.  In that case, 'deparse.level' is obeyed, similarly\n     to the default method.\n\n     In the default method, all the vectors/matrices must be atomic\n     (see 'vector') or lists.  Expressions are not allowed.  Language\n     objects (such as formulae and calls) and pairlists will be coerced\n     to lists: other objects (such as names and external pointers) will\n     be included as elements in a list result.  Any classes the inputs\n     might have are discarded (in particular, factors are replaced by\n     their internal codes).\n\n     If there are several matrix arguments, they must all have the same\n     number of columns (or rows) and this will be the number of columns\n     (or rows) of the result.  If all the arguments are vectors, the\n     number of columns (rows) in the result is equal to the length of\n     the longest vector.  Values in shorter arguments are recycled to\n     achieve this length (with a 'warning' if they are recycled only\n     _fractionally_).\n\n     When the arguments consist of a mix of matrices and vectors the\n     number of columns (rows) of the result is determined by the number\n     of columns (rows) of the matrix arguments.  Any vectors have their\n     values recycled or subsetted to achieve this length.\n\n     For 'cbind' ('rbind'), vectors of zero length (including 'NULL')\n     are ignored unless the result would have zero rows (columns), for\n     S compatibility.  (Zero-extent matrices do not occur in S3 and are\n     not ignored in R.)\n\n     Matrices are restricted to less than 2^31 rows and columns even on\n     64-bit systems.  So input vectors have the same length\n     restriction: as from R 3.2.0 input matrices with more elements\n     (but meeting the row and column restrictions) are allowed.\n\nValue:\n\n     For the default method, a matrix combining the '...' arguments\n     column-wise or row-wise.  (Exception: if there are no inputs or\n     all the inputs are 'NULL', the value is 'NULL'.)\n\n     The type of a matrix result determined from the highest type of\n     any of the inputs in the hierarchy raw < logical < integer <\n     double < complex < character < list .\n\n     For 'cbind' ('rbind') the column (row) names are taken from the\n     'colnames' ('rownames') of the arguments if these are matrix-like.\n     Otherwise from the names of the arguments or where those are not\n     supplied and 'deparse.level > 0', by deparsing the expressions\n     given, for 'deparse.level = 1' only if that gives a sensible name\n     (a 'symbol', see 'is.symbol').\n\n     For 'cbind' row names are taken from the first argument with\n     appropriate names: rownames for a matrix, or names for a vector of\n     length the number of rows of the result.\n\n     For 'rbind' column names are taken from the first argument with\n     appropriate names: colnames for a matrix, or names for a vector of\n     length the number of columns of the result.\n\nData frame methods:\n\n     The 'cbind' data frame method is just a wrapper for\n     'data.frame(..., check.names = FALSE)'.  This means that it will\n     split matrix columns in data frame arguments, and convert\n     character columns to factors unless 'stringsAsFactors = FALSE' is\n     specified.\n\n     The 'rbind' data frame method first drops all zero-column and\n     zero-row arguments.  (If that leaves none, it returns the first\n     argument with columns otherwise a zero-column zero-row data\n     frame.)  It then takes the classes of the columns from the first\n     data frame, and matches columns by name (rather than by position).\n     Factors have their levels expanded as necessary (in the order of\n     the levels of the level sets of the factors encountered) and the\n     result is an ordered factor if and only if all the components were\n     ordered factors.  Old-style categories (integer vectors with\n     levels) are promoted to factors.\n\n     Note that for result column 'j', 'factor(., exclude = X(j))' is\n     applied, where\n\n       X(j) := if(isTRUE(factor.exclude)) {\n                  if(!NA.lev[j]) NA # else NULL\n               } else factor.exclude\n     \n     where 'NA.lev[j]' is true iff any contributing data frame has had\n     a 'factor' in column 'j' with an explicit 'NA' level.\n\nDispatch:\n\n     The method dispatching is _not_ done via 'UseMethod()', but by\n     C-internal dispatching.  Therefore there is no need for, e.g.,\n     'rbind.default'.\n\n     The dispatch algorithm is described in the source file\n     ('.../src/main/bind.c') as\n\n       1. For each argument we get the list of possible class\n          memberships from the class attribute.\n\n       2. We inspect each class in turn to see if there is an\n          applicable method.\n\n       3. If we find a method, we use it.  Otherwise, if there was an\n          S4 object among the arguments, we try S4 dispatch; otherwise,\n          we use the default code.\n\n     If you want to combine other objects with data frames, it may be\n     necessary to coerce them to data frames first.  (Note that this\n     algorithm can result in calling the data frame method if all the\n     arguments are either data frames or vectors, and this will result\n     in the coercion of character vectors to factors.)\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'c' to combine vectors (and lists) as vectors, 'data.frame' to\n     combine vectors and matrices as a data frame.\n\nExamples:\n\n     m <- cbind(1, 1:7) # the '1' (= shorter vector) is recycled\n     m\n     m <- cbind(m, 8:14)[, c(1, 3, 2)] # insert a column\n     m\n     cbind(1:7, diag(3)) # vector is subset -> warning\n     \n     cbind(0, rbind(1, 1:3))\n     cbind(I = 0, X = rbind(a = 1, b = 1:3))  # use some names\n     xx <- data.frame(I = rep(0,2))\n     cbind(xx, X = rbind(a = 1, b = 1:3))   # named differently\n     \n     cbind(0, matrix(1, nrow = 0, ncol = 4)) #> Warning (making sense)\n     dim(cbind(0, matrix(1, nrow = 2, ncol = 0))) #-> 2 x 1\n     \n     ## deparse.level\n     dd <- 10\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 0) # middle 2 rownames\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 1) # 3 rownames (default)\n     rbind(1:4, c = 2, \"a++\" = 10, dd, deparse.level = 2) # 4 rownames\n     \n     ## cheap row names:\n     b0 <- gl(3,4, labels=letters[1:3])\n     bf <- setNames(b0, paste0(\"o\", seq_along(b0)))\n     df  <- data.frame(a = 1, B = b0, f = gl(4,3))\n     df. <- data.frame(a = 1, B = bf, f = gl(4,3))\n     new <- data.frame(a = 8, B =\"B\", f = \"1\")\n     (df1  <- rbind(df , new))\n     (df.1 <- rbind(df., new))\n     stopifnot(identical(df1, rbind(df,  new, make.row.names=FALSE)),\n               identical(df1, rbind(df., new, make.row.names=FALSE)))\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?do.call\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nExecute a Function Call\n\nDescription:\n\n     'do.call' constructs and executes a function call from a name or a\n     function and a list of arguments to be passed to it.\n\nUsage:\n\n     do.call(what, args, quote = FALSE, envir = parent.frame())\n     \nArguments:\n\n    what: either a function or a non-empty character string naming the\n          function to be called.\n\n    args: a _list_ of arguments to the function call.  The 'names'\n          attribute of 'args' gives the argument names.\n\n   quote: a logical value indicating whether to quote the arguments.\n\n   envir: an environment within which to evaluate the call.  This will\n          be most useful if 'what' is a character string and the\n          arguments are symbols or quoted expressions.\n\nDetails:\n\n     If 'quote' is 'FALSE', the default, then the arguments are\n     evaluated (in the calling environment, not in 'envir').  If\n     'quote' is 'TRUE' then each argument is quoted (see 'quote') so\n     that the effect of argument evaluation is to remove the quotes -\n     leaving the original arguments unevaluated when the call is\n     constructed.\n\n     The behavior of some functions, such as 'substitute', will not be\n     the same for functions evaluated using 'do.call' as if they were\n     evaluated from the interpreter.  The precise semantics are\n     currently undefined and subject to change.\n\nValue:\n\n     The result of the (evaluated) function call.\n\nWarning:\n\n     This should not be used to attempt to evade restrictions on the\n     use of '.Internal' and other non-API calls.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'call' which creates an unevaluated call.\n\nExamples:\n\n     do.call(\"complex\", list(imaginary = 1:3))\n     \n     ## if we already have a list (e.g., a data frame)\n     ## we need c() to add further arguments\n     tmp <- expand.grid(letters[1:2], 1:3, c(\"+\", \"-\"))\n     do.call(\"paste\", c(tmp, sep = \"\"))\n     \n     do.call(paste, list(as.name(\"A\"), as.name(\"B\")), quote = TRUE)\n     \n     ## examples of where objects will be found.\n     A <- 2\n     f <- function(x) print(x^2)\n     env <- new.env()\n     assign(\"A\", 10, envir = env)\n     assign(\"f\", f, envir = env)\n     f <- function(x) print(x)\n     f(A)                                      # 2\n     do.call(\"f\", list(A))                     # 2\n     do.call(\"f\", list(A), envir = env)        # 4\n     do.call( f,  list(A), envir = env)        # 2\n     do.call(\"f\", list(quote(A)), envir = env) # 100\n     do.call( f,  list(quote(A)), envir = env) # 10\n     do.call(\"f\", list(as.name(\"A\")), envir = env) # 100\n     \n     eval(call(\"f\", A))                      # 2\n     eval(call(\"f\", quote(A)))               # 2\n     eval(call(\"f\", A), envir = env)         # 4\n     eval(call(\"f\", quote(A)), envir = env)  # 100\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n* OK, so basically what happened is that\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndo.call(rbind, list)\n```\n:::\n\n\n\n\n* Gets transformed into\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(list[[1]], list[[2]], list[[3]], ..., list[[length(list)]])\n```\n:::\n\n\n\n\n* That's vectorization magic!\n\n## You try it! (if we have time) {.smaller}\n\n* Use the code you wrote before the get the incidence per 1000 people on the\nentire measles data set (add a column for incidence to the full data).\n* Use the code `plot(NULL, NULL, ...)` to make a blank plot. You will need to\nset the `xlim` and `ylim` arguments to sensible values, and specify the axis\ntitles as \"Year\" and \"Incidence per 1000 people\".\n* Using a `for` loop and the `lines()` function, make a plot that shows all of\nthe incidence curves over time, overlapping on the plot.\n* HINT: use `col = adjustcolor(black, alpha.f = 0.25)` to make the curves\npartially transparent, so you can see the overlap.\n* BONUS PROBLEM: using the function `cumsum()`, make a plot of the cumulative\ncases (not standardized) over time for all of the countries. (Dealing with\nthe NA's here is tricky!!)\n\n## Main problem solution\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeas$cases_per_thousand <- meas$Cases / as.numeric(meas$total_pop) * 1000\ncountries <- unique(meas$country)\n\nplot(\n\tNULL, NULL,\n\txlim = c(1980, 2022),\n\tylim = c(0, 50),\n\txlab = \"Year\",\n\tylab = \"Incidence per 1000 people\"\n)\n\nfor (i in 1:length(countries)) {\n\tcountry_data <- subset(meas, country == countries[[i]])\n\tlines(\n\t\tx = country_data$time,\n\t\ty = country_data$cases_per_thousand,\n\t\tcol = adjustcolor(\"black\", alpha.f = 0.25)\n\t)\n}\n```\n:::\n\n\n\n\n## Main problem solution\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Module13-Iteration_files/figure-revealjs/unnamed-chunk-32-1.png){width=960}\n:::\n:::\n\n\n\n\n## Bonus problem solution\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First calculate the cumulative cases, treating NA as zeroes\ncumulative_cases <- ave(\n\tx = ifelse(is.na(meas$Cases), 0, meas$Cases),\n\tmeas$country,\n\tFUN = cumsum\n)\n\n# Now put the NAs back where they should be\nmeas$cumulative_cases <- cumulative_cases + (meas$Cases * 0)\n\nplot(\n\tNULL, NULL,\n\txlim = c(1980, 2022),\n\tylim = c(1, 6.2e6),\n\txlab = \"Year\",\n\tylab = paste0(\"Cumulative cases since\", min(meas$time))\n)\n\nfor (i in 1:length(countries)) {\n\tcountry_data <- subset(meas, country == countries[[i]])\n\tlines(\n\t\tx = country_data$time,\n\t\ty = country_data$cumulative_cases,\n\t\tcol = adjustcolor(\"black\", alpha.f = 0.25)\n\t)\n}\n\ntext(\n\tx = 2020,\n\ty = 6e6,\n\tlabels = \"China →\"\n)\n```\n:::\n\n\n\n\n## Bonus problem solution\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Module13-Iteration_files/figure-revealjs/unnamed-chunk-34-1.png){width=960}\n:::\n:::\n\n\n\n\n## More practice on your own {.smaller}\n\n* Merge the `countries-regions.csv` data with the `measles_final.Rds` data.\nReshape the measles data so that `MCV1` and `MCV2` vaccine coverage are two\nseparate columns. Then use a loop to fit a poisson regression model for each\ncontinent where `Cases` is the outcome, and `MCV1 coverage` and `MCV2 coverage`\nare the predictors. Discuss your findings, and try adding an interation term.\n* Assess the impact of `age_months` as a confounder in the Diphtheria serology\ndata. First, write code to transform `age_months` into age ranges for each\nyear. Then, using a loop, calculate the crude odds ratio for the effect of\nvaccination on infection for each of the age ranges. How does the odds ratio\nchange as age increases? Can you formalize this analysis by fitting a logistic\nregression model with `age_months` and vaccination as predictors?\n\n\n",
    "supporting": [
      "Module13-Iteration_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}