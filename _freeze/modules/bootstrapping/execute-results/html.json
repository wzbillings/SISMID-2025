{
  "hash": "34887dcf11699ddd6d7b4937d4bfbe43",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module XX: Bootstrapping can be easy and fun\"\nformat:\n  revealjs:\n    toc: false\n---\n\n\n\n\n## Learning goals\n\n1.  Understand the basics of bootstrapping -- be able to construct your own bootstrap resamples and calculate a bootstrap CI for a statistic.\n2.  Make your own bootstraps with loops or functional programming.\n3.  Combine your own knowledge of R programming techniques with the `boot` package for easy bootstrapping.\n4.  Use the `rsample` package and advanced R programming techniques to iterate over lists of bootstrap resamples.\n\n## What is bootstrapping? {.scrollable}\n\n- **bootstrapping** is a method for obtaining standard error estimates or confidence intervals by **resampling**.\n- We'll specifically talk about the **nonparametric bootstrap** but there are entire books about bootstrap methods.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![credit: https://commons.wikimedia.org/wiki/File:Illustration_bootstrap.svg](../images/Illustration_bootstrap.svg.png)\n:::\n:::\n\n\n## What is bootstrapping? {.incremental}\n\n- We have some statistic $\\theta$ that we want to estimate from the dataset.\n- We create $B$ resamples of the dataset by randomly sampling from it, and then we calculate the statistic $\\theta_B$ on each dataset.\n- If we create these resamples the correct way, the observed distribution of $\\theta_1, \\ldots, \\theta_B$ will converge to the true sampling distribution of $\\theta$.\n- Specifically, we create a resample by sampling $n$ (our sample size) rows from the original dataset **with replacement**.\n\n## What is bootstrapping?\n\n- That's math jargon to say that sometimes doing this resampling thing will give us better confidence intervals than normality assumptions.\n- Usually bootstrapping works well for small datasets, estimates with complex (or nonexistant) standard error formulas, or for statistics with highly skewed distributions.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![credit: https://commons.wikimedia.org/wiki/File:Illustration_bootstrap.svg](../images/Illustration_bootstrap.svg.png)\n:::\n:::\n\n\n## Low birthweight data and the `data()` function\n\n-   For this example, we'll use a famous epidemiological dataset about babies with low birthweight.\n-   Many R packages have built-in datasets, which you can access with the `data()` function.\n-   The low birth weight dataset, called `birthwt`, is in the `MASS` package, so you can access it with either `MASS::birthwt` or `data(\"birthwt\", package = \"MASS\")`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This will create the global variable \"birthwt\"\ndata(\"birthwt\", package = \"MASS\")\n```\n:::\n\n\n## Bootstrapping example {.scrollable}\n\n- Use bootstrapping to calculate a 95\\% CI for the risk difference in low birth weight (`low`, 1 is low birth weight) between mothers who smoke (`smoke = 1`) and don't (`smoke` = 0).\n\n. . .\n\n- First create the resamples. **We need to use `set.seed()` to make sure our results are the same every time we run our code!**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(370)\nB <- 1000\n# Alternatively use replicate() if you don't like the weird function here\n# or use a loop\nresamples <- lapply(\n\t1:B,\n\t\\(n) birthwt[sample.int(nrow(birthwt), replace = TRUE), ]\n)\n\nstr(resamples, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 1000\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n $ :'data.frame':\t189 obs. of  10 variables:\n  [list output truncated]\n```\n\n\n:::\n:::\n\n\n. . .\n\n- Now write a function to calculate the statistic.\n- Make sure to calculate the point estimate on the entire dataset as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrd_smoking <- function(resample) {\n\trisk_smoke <- mean(resample$low[resample$smoke == 1])\n\trisk_no_smoke <- mean(resample$low[resample$smoke == 0])\n\t\n\trd <- risk_smoke - risk_no_smoke\n\treturn(rd)\n}\n\npoint_estimate_rd <- rd_smoking(birthwt)\npoint_estimate_rd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1532315\n```\n\n\n:::\n:::\n\n\n. . .\n\n- Now calculate the statistic on every resample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrap_rd <- sapply(resamples, rd_smoking)\nstr(bootstrap_rd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:1000] 0.2051 0.0224 0.2446 0.1094 0.142 ...\n```\n\n\n:::\n:::\n\n\n. . .\n\n- Now we have to calculate the SE. There are a few different ways. First is the **normal method**, where we calculate the standard error from the bootstrap distribution.\n- This is just the standard deviation of the bootstrap estimates. Then we calculate the normal-approximate CI as usual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_se <- sd(bootstrap_rd)\npoint_estimate_rd + boot_se * c(-1.96, 1.96)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.006663599 0.299799385\n```\n\n\n:::\n:::\n\n\n. . .\n\n- That method is kind of bad, but common. A better method is the **percentile method** which uses the quantiles of the bootstrap estimates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile(bootstrap_rd, prob = c(0.025, 0.975))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       2.5%       97.5% \n0.009800072 0.301920525 \n```\n\n\n:::\n:::\n\n\n- In this case they're the same because this RD is easy to estimate. But that won't always be true!\n\n## You try it! {.scrollable}\n\n- Look up the formula for the standard error of the risk ratio.\n- Calculate the risk ratio for low birthweight in mothers with (`ht` = 1) and without (`ht = 0`) a history of hypertension using the standard CI, and using a bootstrap CI with the percentile method.\n\n. . .\n\n- Hint: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrr_ht <- function(resample) {\n\trisk_ht_1 <- mean(resample$low[resample$ht == 1])\n\trisk_ht_0 <- mean(resample$low[resample$ht == 0])\n\t\n\trr <- risk_ht_1 / risk_ht_0\n\treturn(rr)\n}\n```\n:::\n\n\n- Hint: the formula for the SE of the **log** risk ratio is\n$$\n\\sqrt{\\bigg( \\frac{1}{a} + \\frac{1}{c} \\bigg) - \\bigg( \\frac{1}{a+b} + \\frac{1}{c+d}  \\bigg)}\n$$\n\nfor a $2\\times2$ table.\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|          |Exposed |Unexposed |\n|:---------|:-------|:---------|\n|Exposed   |a       |b         |\n|Unexposed |c       |d         |\n:::\n:::\n\n\n. . .\n\n- Solution: first we calculate the point estimate and the Wald-type CI based on the SE formula.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoint_estimate_rr <- rr_ht(birthwt)\ncontigency_table_ht <- table(\n\tfactor(birthwt$ht, c(1, 0), c(\"Exposed\", \"Unexposed\")),\n\tfactor(birthwt$smoke, c(1, 0), c(\"Case\", \"Control\"))\n)\n\ncalculate_log_rr_se <- function(contigency_table) {\n\ta <- contigency_table[1, 1]\n\tb <- contigency_table[1, 2]\n\tc <- contigency_table[2, 1]\n\td <- contigency_table[2, 2]\n\t\n\tse <- sqrt((1/a + 1/c) - (1/(a+b) + 1/(c+d)))\n\treturn(se)\n}\nlog_rr_se <- calculate_log_rr_se(contigency_table_ht)\n# It's on the log scale, so we have to calculate the CI like this!\nexp(log_rr_se * c(-1.96, 1.96) + log(point_estimate_rr))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9915692 3.9760368\n```\n\n\n:::\n:::\n\n\n. . .\n\n- Solution: now we do the bootstrap CI.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrr_ht <- function(resample) {\n\trisk_ht_1 <- mean(resample$low[resample$ht == 1])\n\trisk_ht_0 <- mean(resample$low[resample$ht == 0])\n\t\n\trr <- risk_ht_1 / risk_ht_0\n\treturn(rr)\n}\n\nbootstrap_rr <- sapply(resamples, rr_ht)\nquantile(bootstrap_rr, c(0.025, 0.975))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    2.5%    97.5% \n1.032770 3.237805 \n```\n\n\n:::\n:::\n\n\n## Bootstrapping multiple statistics at one time\n\n- If our bootstrap function returns a `vector`, we can get multiple statistics at once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_smoking_stats <- function(resample) {\n\trisk_smoke <- mean(resample$low[resample$smoke == 1])\n\trisk_no_smoke <- mean(resample$low[resample$smoke == 0])\n\t\n\todds_smoke <- risk_smoke / (1 - risk_smoke)\n\todds_no_smoke <- risk_no_smoke / (1 - risk_no_smoke)\n\t\n\trd <- risk_smoke - risk_no_smoke\n\trr <- risk_smoke / risk_no_smoke\n\tor <- odds_smoke / odds_no_smoke\n\t\n\tout <- c(\n\t\t\"Risk difference\" = rd,\n\t\t\"Risk ratio\" = rr,\n\t\t\"Odds ratio\" = or\n\t)\n\treturn(out)\n}\n\nsmoking_stats <- sapply(resamples, get_smoking_stats)\nstr(smoking_stats)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:3, 1:1000] 0.2051 2.0082 2.7044 0.0224 1.0879 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : chr [1:3] \"Risk difference\" \"Risk ratio\" \"Odds ratio\"\n  ..$ : NULL\n```\n\n\n:::\n:::\n\n\n- The output looks really confusing. But it's a matrix so we can use `apply()`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoint_estimates <- get_smoking_stats(birthwt)\nboot_cis <- apply(smoking_stats, 1, \\(x) quantile(x, c(0.025, 0.975)))\n\n# Just some code to show everything neatly\nrbind(\n\t\"Lower\" = boot_cis[1, ],\n\t\"Point\" = point_estimates,\n\t\"Upper\" = boot_cis[2, ]\n) |>\n\tt() |>\n\tround(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|                | Lower| Point| Upper|\n|:---------------|-----:|-----:|-----:|\n|Risk difference |  0.01|  0.15|  0.30|\n|Risk ratio      |  1.04|  1.61|  2.57|\n|Odds ratio      |  1.05|  2.02|  4.18|\n:::\n:::\n\n\n## Errors in bootstrapping and the `boot` package\n\n- The situations we just observed are pretty simple, and our bootstrap estimates are pretty trustworthy (they would be more trustworthy if we increased `B`, a good rule of thumb is 1,000 just for you, 10,000 for your boss, and 100,000 for a paper if it's feasible).\n- But in some situations, bootstrapping can be **biased**. There is a fix for this called the \"BCa\" bootstrap.\n- BCa is hard to do by hand, but easy to do with the `boot` package.\n\n## The `boot` package {.scrollable}\n\n- We have to write our function a certain way for `boot`. It must have two arguments, the first is the data, and the second is a list of indices that are included in a resample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_smoking_stats <- function(data, idx) {\n\tresample <- data[idx, ]\n\tout <- get_smoking_stats(resample)\n\treturn(out)\n}\n\nlibrary(boot)\nbootstraps_smoking <- boot::boot(birthwt, boot_smoking_stats, R = 1000)\nbootstraps_smoking\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nORDINARY NONPARAMETRIC BOOTSTRAP\n\n\nCall:\nboot::boot(data = birthwt, statistic = boot_smoking_stats, R = 1000)\n\n\nBootstrap Statistics :\n     original       bias    std. error\nt1* 0.1532315 0.0009951909  0.07034402\nt2* 1.6076421 0.0444346127  0.35834007\nt3* 2.0219436 0.1290172225  0.71556649\n```\n\n\n:::\n:::\n\n\n. . .\n\n- We can see this calculates the point estimate, bias, and boostrap SE for us. The bias is what we didn't know how to calculate before.\n- We can easily compare multiple CI methods with `boot`.\n- For technical reasons that are too complicated to talk about, when you do multiple stats at one time in `boot`, you must ***always*** manually set the `index` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Four bootstrap CIs for the risk difference\nboot::boot.ci(bootstraps_smoking, index = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in boot::boot.ci(bootstraps_smoking, index = 1): bootstrap variances\nneeded for studentized intervals\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 1000 bootstrap replicates\n\nCALL : \nboot::boot.ci(boot.out = bootstraps_smoking, index = 1)\n\nIntervals : \nLevel      Normal              Basic         \n95%   ( 0.0144,  0.2901 )   ( 0.0200,  0.2876 )  \n\nLevel     Percentile            BCa          \n95%   ( 0.0189,  0.2864 )   ( 0.0153,  0.2834 )  \nCalculations and Intervals on Original Scale\n```\n\n\n:::\n:::\n\n\n. . .\n\n- Of course, we can use loops or FP to do this for all of our statistics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmoking_point_estimates <- bootstraps_smoking$t0\nsmoking_cis_list <- lapply(\n\t1:length(smoking_point_estimates),\n\t\\(i) boot::boot.ci(bootstraps_smoking, type = \"bca\", index = i)\n)\nstr(smoking_cis_list, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ :List of 4\n  ..- attr(*, \"class\")= chr \"bootci\"\n $ :List of 4\n  ..- attr(*, \"class\")= chr \"bootci\"\n $ :List of 4\n  ..- attr(*, \"class\")= chr \"bootci\"\n```\n\n\n:::\n:::\n\n\n- Cleaning them up is kind of difficult, this is a weirdly formatted S3 object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmoking_cis <- sapply(\n\tsmoking_cis_list,\n\t\\(x) x$bca[4:5]\n)\n\n# Same cleanup code as before\nrbind(\n\t\"lower\" = smoking_cis[1, ],\n\t\"point\" = smoking_point_estimates,\n\t\"upper\" = smoking_cis[2, ]\n) |>\n\tt() |>\n\tround(digits = 2)\n```\n\n::: {.cell-output-display}\n\n\n|                | lower| point| upper|\n|:---------------|-----:|-----:|-----:|\n|Risk difference |  0.02|  0.15|  0.28|\n|Risk ratio      |  1.05|  1.61|  2.42|\n|Odds ratio      |  1.07|  2.02|  3.67|\n:::\n:::\n\n\n## You try it!\n\n- Fit a logistic regression model to predict low birth weight using this dataset. Use any predictors in the dataset that you think are relevant.\n- Get the standard confidence intervals using the profile method (that is, with `confint()`).\n- Get bootstrap estimates for the coefficients.\n- Do the bootstrap estimates lead you to the same interpretation, or a different interpretation?\n\n(No solution typed up for this problem, if we have time/interest we can cover it together.)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}