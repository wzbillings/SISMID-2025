{
  "hash": "a3288c5122c31e58f8ecab5ed04395c2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 8: Data Merging and Reshaping\"\nformat:\n  revealjs:\n    scrollable: true\n    smaller: true\n    toc: false\n---\n\n\n## Learning Objectives\n\nAfter module 8, you should be able to...\n\n-   Merge/join data together\n-   Reshape data from wide to long\n-   Reshape data from long to wide\n\n## Joining types\n\nPay close attention to the number of rows in your data set before and after a join. This will help flag when an issue has arisen. This will depend on the type of merge:\n\n-   1:1 merge (one-to-one merge) – Simplest merge (sometimes things go wrong)\n-   1:m merge (one-to-many merge) – More complex (things often go wrong)\n    -   The \"one\" suggests that one dataset has the merging variable (e.g., id) each represented once and the \"many” implies that one dataset has the merging variable represented multiple times\n-   m:m merge (many-to-many merge) – Danger zone (can be unpredictable)\n    \n\n## one-to-one merge\n\n-   This means that each row of data represents a unique unit of analysis that exists in another dataset (e.g,. id variable)\n-   Will likely have variables that don’t exist in the current dataset (that’s why you are trying to merge it in)\n-   The merging variable (e.g., id) each represented a single time\n-   You should try to structure your data so that a 1:1 merge or 1:m merge is possible so that fewer things can go wrong.\n\n## `merge()` function\n\nWe will use the `merge()` function to conduct one-to-one merge\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?merge\n```\n:::\n\n\n```\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\n```\n\nMerge Two Data Frames\n\nDescription:\n\n     Merge two data frames by common columns or row names, or do other\n     versions of database _join_ operations.\n\nUsage:\n\n     merge(x, y, ...)\n     \n     ## Default S3 method:\n     merge(x, y, ...)\n     \n     ## S3 method for class 'data.frame'\n     merge(x, y, by = intersect(names(x), names(y)),\n           by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n           sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n           incomparables = NULL, ...)\n     \nArguments:\n\n    x, y: data frames, or objects to be coerced to one.\n\nby, by.x, by.y: specifications of the columns used for merging.  See\n          'Details'.\n\n     all: logical; 'all = L' is shorthand for 'all.x = L' and 'all.y =\n          L', where 'L' is either 'TRUE' or 'FALSE'.\n\n   all.x: logical; if 'TRUE', then extra rows will be added to the\n          output, one for each row in 'x' that has no matching row in\n          'y'.  These rows will have 'NA's in those columns that are\n          usually filled with values from 'y'.  The default is 'FALSE',\n          so that only rows with data from both 'x' and 'y' are\n          included in the output.\n\n   all.y: logical; analogous to 'all.x'.\n\n    sort: logical.  Should the result be sorted on the 'by' columns?\n\nsuffixes: a character vector of length 2 specifying the suffixes to be\n          used for making unique the names of columns in the result\n          which are not used for merging (appearing in 'by' etc).\n\n no.dups: logical indicating that 'suffixes' are appended in more cases\n          to avoid duplicated column names in the result.  This was\n          implicitly false before R version 3.5.0.\n\nincomparables: values which cannot be matched.  See 'match'.  This is\n          intended to be used for merging on one column, so these are\n          incomparable values of that column.\n\n     ...: arguments to be passed to or from methods.\n\nDetails:\n\n     'merge' is a generic function whose principal method is for data\n     frames: the default method coerces its arguments to data frames\n     and calls the '\"data.frame\"' method.\n\n     By default the data frames are merged on the columns with names\n     they both have, but separate specifications of the columns can be\n     given by 'by.x' and 'by.y'.  The rows in the two data frames that\n     match on the specified columns are extracted, and joined together.\n     If there is more than one match, all possible matches contribute\n     one row each.  For the precise meaning of 'match', see 'match'.\n\n     Columns to merge on can be specified by name, number or by a\n     logical vector: the name '\"row.names\"' or the number '0' specifies\n     the row names.  If specified by name it must correspond uniquely\n     to a named column in the input.\n\n     If 'by' or both 'by.x' and 'by.y' are of length 0 (a length zero\n     vector or 'NULL'), the result, 'r', is the _Cartesian product_ of\n     'x' and 'y', i.e., 'dim(r) = c(nrow(x)*nrow(y), ncol(x) +\n     ncol(y))'.\n\n     If 'all.x' is true, all the non matching cases of 'x' are appended\n     to the result as well, with 'NA' filled in the corresponding\n     columns of 'y'; analogously for 'all.y'.\n\n     If the columns in the data frames not used in merging have any\n     common names, these have 'suffixes' ('\".x\"' and '\".y\"' by default)\n     appended to try to make the names of the result unique.  If this\n     is not possible, an error is thrown.\n\n     If a 'by.x' column name matches one of 'y', and if 'no.dups' is\n     true (as by default), the y version gets suffixed as well,\n     avoiding duplicate column names in the result.\n\n     The complexity of the algorithm used is proportional to the length\n     of the answer.\n\n     In SQL database terminology, the default value of 'all = FALSE'\n     gives a _natural join_, a special case of an _inner join_.\n     Specifying 'all.x = TRUE' gives a _left (outer) join_, 'all.y =\n     TRUE' a _right (outer) join_, and both ('all = TRUE') a _(full)\n     outer join_.  DBMSes do not match 'NULL' records, equivalent to\n     'incomparables = NA' in R.\n\nValue:\n\n     A data frame.  The rows are by default lexicographically sorted on\n     the common columns, but for 'sort = FALSE' are in an unspecified\n     order.  The columns are the common columns followed by the\n     remaining columns in 'x' and then those in 'y'.  If the matching\n     involved row names, an extra character column called 'Row.names'\n     is added at the left, and in all cases the result has 'automatic'\n     row names.\n\nNote:\n\n     This is intended to work with data frames with vector-like\n     columns: some aspects work with data frames containing matrices,\n     but not all.\n\n     Currently long vectors are not accepted for inputs, which are thus\n     restricted to less than 2^31 rows. That restriction also applies\n     to the result for 32-bit platforms.\n\nSee Also:\n\n     'data.frame', 'by', 'cbind'.\n\n     'dendrogram' for a class which has a 'merge' method.\n\nExamples:\n\n     authors <- data.frame(\n         ## I(*) : use character columns of names to get sensible sort order\n         surname = I(c(\"Tukey\", \"Venables\", \"Tierney\", \"Ripley\", \"McNeil\")),\n         nationality = c(\"US\", \"Australia\", \"US\", \"UK\", \"Australia\"),\n         deceased = c(\"yes\", rep(\"no\", 4)))\n     authorN <- within(authors, { name <- surname; rm(surname) })\n     books <- data.frame(\n         name = I(c(\"Tukey\", \"Venables\", \"Tierney\",\n                  \"Ripley\", \"Ripley\", \"McNeil\", \"R Core\")),\n         title = c(\"Exploratory Data Analysis\",\n                   \"Modern Applied Statistics ...\",\n                   \"LISP-STAT\",\n                   \"Spatial Statistics\", \"Stochastic Simulation\",\n                   \"Interactive Data Analysis\",\n                   \"An Introduction to R\"),\n         other.author = c(NA, \"Ripley\", NA, NA, NA, NA,\n                          \"Venables & Smith\"))\n     \n     (m0 <- merge(authorN, books))\n     (m1 <- merge(authors, books, by.x = \"surname\", by.y = \"name\"))\n      m2 <- merge(books, authors, by.x = \"name\", by.y = \"surname\")\n     stopifnot(exprs = {\n        identical(m0, m2[, names(m0)])\n        as.character(m1[, 1]) == as.character(m2[, 1])\n        all.equal(m1[, -1], m2[, -1][ names(m1)[-1] ])\n        identical(dim(merge(m1, m2, by = NULL)),\n                  c(nrow(m1)*nrow(m2), ncol(m1)+ncol(m2)))\n     })\n     \n     ## \"R core\" is missing from authors and appears only here :\n     merge(authors, books, by.x = \"surname\", by.y = \"name\", all = TRUE)\n     \n     \n     ## example of using 'incomparables'\n     x <- data.frame(k1 = c(NA,NA,3,4,5), k2 = c(1,NA,NA,4,5), data = 1:5)\n     y <- data.frame(k1 = c(NA,2,NA,4,5), k2 = c(NA,NA,3,4,5), data = 1:5)\n     merge(x, y, by = c(\"k1\",\"k2\")) # NA's match\n     merge(x, y, by = \"k1\") # NA's match, so 6 rows\n     merge(x, y, by = \"k2\", incomparables = NA) # 2 rows\n\n\n## Join Types\n\n- Full join: includes all unique observations in object df.x and df.y\n    - `merged.df <- merge(df.x, df.y, all.x=T, all.y=T, by=merge_variable)`\n    -  arguments `all = TRUE` is the same as `all.x = TRUE, all.y = TRUE`\n    -  the number of rows in `merged.df` is >= max(nrow(df.x), nrow(df.y))\n- Inner join: includes observations that are in both df.x and df.y\n    - `merged.df <- merge(df.x, df.y, all.x=F, all.y=F, by=merge_variable)`\n    - the number of rows in `merged.df` is <= min(nrow(df.x), nrow(df.y))\n- Left join: joining on the first object (df.x) so it includes observations that in df.x\n    - `merged.df <- merge(df.x, df.y, all.x=T, all.y=F, by=merge_variable)`\n    - the number of rows in `merged.df` is nrow(df.x)\n- Right join: joining on the second object (df.y) so it includes observations that in df.y\n    - `merged.df <- merge(df.x, df.y, all.x=F, all.y=T, by=merge_variable)`\n    - the number of rows in `merged.df` is nrow(df.y)\n    \n## Lets import the new data we want to merge and take a look\n\nThe new data `serodata_new.csv` represents a follow-up serological survey four years later. At this follow-up individuals were retested for IgG antibody concentrations and their ages were collected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_new <- read.csv(\"data/serodata_new.csv\")\nstr(df_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t636 obs. of  3 variables:\n $ observation_id   : int  5772 8095 9784 9338 6369 6885 6252 8913 7332 6941 ...\n $ IgG_concentration: num  0.261 2.981 0.282 136.638 0.381 ...\n $ age              : int  6 8 8 8 5 8 8 NA 8 6 ...\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(df_new)\n```\n\n::: {.cell-output-display}\n\n\n|   |observation_id |IgG_concentration |     age      |\n|:--|:--------------|:-----------------|:-------------|\n|   |Min.   :5006   |Min.   :  0.0051  |Min.   : 5.00 |\n|   |1st Qu.:6328   |1st Qu.:  0.2751  |1st Qu.: 7.00 |\n|   |Median :7494   |Median :  1.5477  |Median :10.00 |\n|   |Mean   :7490   |Mean   : 82.7684  |Mean   :10.63 |\n|   |3rd Qu.:8736   |3rd Qu.:129.6389  |3rd Qu.:14.00 |\n|   |Max.   :9982   |Max.   :950.6590  |Max.   :19.00 |\n|   |NA             |NA                |NA's   :9     |\n:::\n:::\n\n\n\n## Merge the new data with the original data\n\nLets load the old data as well and look for a variable, or variables, to merge by.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\"data/serodata.csv\")\ncolnames(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"observation_id\"    \"IgG_concentration\" \"age\"              \n[4] \"gender\"            \"slum\"             \n```\n\n\n:::\n:::\n\n\nWe notice that `observation_id` seems to be the obvious variable by which to merge.  However, we also realize that `IgG_concentration` and `age` are the exact same names.  If we merge now we see that R has forced the `IgG_concentration` and `age` to have a `.x` or `.y` to make sure that these variables are different.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(merge(df, df_new, all.x=T, all.y=T, by=c('observation_id')))\n```\n\n::: {.cell-output-display}\n\n\n| observation_id| IgG_concentration.x| age.x|gender |slum     | IgG_concentration.y| age.y|\n|--------------:|-------------------:|-----:|:------|:--------|-------------------:|-----:|\n|           5006|         164.2979452|     7|Male   |Non slum |         155.5811325|    11|\n|           5024|           0.3000000|     5|Female |Non slum |           0.2918605|     9|\n|           5026|           0.3000000|    10|Female |Non slum |           0.2542945|    14|\n|           5030|           0.0555556|     7|Female |Non slum |           0.0533262|    11|\n|           5035|          26.2112514|    11|Female |Non slum |          22.0159300|    15|\n|           5054|           0.3000000|     3|Male   |Non slum |           0.2709671|     7|\n:::\n:::\n\n\n## Merge the new data with the original data\n\nWhat do we do?\n\nThe first option is to rename the `IgG_concentration` and `age` variables before the merge, so that it is clear which is time point 1 and time point 2. \n\n::: {.cell}\n\n```{.r .cell-code}\ndf$IgG_concentration_time1 <- df$IgG_concentration\ndf$age_time1 <- df$age\ndf$IgG_concentration <- df$age <- NULL #remove the original variables\n\ndf_new$IgG_concentration_time2 <- df_new$IgG_concentration\ndf_new$age_time2 <- df_new$age\ndf_new$IgG_concentration <- df_new$age <- NULL #remove the original variables\n```\n:::\n\n\nNow, lets merge.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_all_wide <- merge(df, df_new, all.x=T, all.y=T, by=c('observation_id'))\nstr(df_all_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t651 obs. of  7 variables:\n $ observation_id         : int  5006 5024 5026 5030 5035 5054 5057 5063 5064 5080 ...\n $ gender                 : chr  \"Male\" \"Female\" \"Female\" \"Female\" ...\n $ slum                   : chr  \"Non slum\" \"Non slum\" \"Non slum\" \"Non slum\" ...\n $ IgG_concentration_time1: num  164.2979 0.3 0.3 0.0556 26.2113 ...\n $ age_time1              : int  7 5 10 7 11 3 3 12 14 6 ...\n $ IgG_concentration_time2: num  155.5811 0.2919 0.2543 0.0533 22.0159 ...\n $ age_time2              : int  11 9 14 11 15 7 7 16 18 10 ...\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(df_all_wide)\n```\n\n::: {.cell-output-display}\n\n\n| observation_id|gender |slum     | IgG_concentration_time1| age_time1| IgG_concentration_time2| age_time2|\n|--------------:|:------|:--------|-----------------------:|---------:|-----------------------:|---------:|\n|           5006|Male   |Non slum |             164.2979452|         7|             155.5811325|        11|\n|           5024|Female |Non slum |               0.3000000|         5|               0.2918605|         9|\n|           5026|Female |Non slum |               0.3000000|        10|               0.2542945|        14|\n|           5030|Female |Non slum |               0.0555556|         7|               0.0533262|        11|\n|           5035|Female |Non slum |              26.2112514|        11|              22.0159300|        15|\n|           5054|Male   |Non slum |               0.3000000|         3|               0.2709671|         7|\n:::\n:::\n\n\n## Merge the new data with the original data\n\nThe second option is to add a time variable to the two data sets and then merge by `observation_id`, `time`, `age`, and `IgG_concentration`. Note, I need to read in the data again b/c I removed the `IgG_concentration` and `age` variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(\"data/serodata.csv\")\ndf_new <- read.csv(\"data/serodata_new.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$time <- 1 #you can put in one number and it will repeat it\ndf_new$time <- 2\nhead(df)\n```\n\n::: {.cell-output-display}\n\n\n| observation_id| IgG_concentration| age|gender |slum     | time|\n|--------------:|-----------------:|---:|:------|:--------|----:|\n|           5772|         0.3176895|   2|Female |Non slum |    1|\n|           8095|         3.4368231|   4|Female |Non slum |    1|\n|           9784|         0.3000000|   4|Male   |Non slum |    1|\n|           9338|       143.2363014|   4|Male   |Non slum |    1|\n|           6369|         0.4476534|   1|Male   |Non slum |    1|\n|           6885|         0.0252708|   4|Male   |Non slum |    1|\n:::\n\n```{.r .cell-code}\nhead(df_new)\n```\n\n::: {.cell-output-display}\n\n\n| observation_id| IgG_concentration| age| time|\n|--------------:|-----------------:|---:|----:|\n|           5772|         0.2612388|   6|    2|\n|           8095|         2.9809049|   8|    2|\n|           9784|         0.2819489|   8|    2|\n|           9338|       136.6382260|   8|    2|\n|           6369|         0.3810119|   5|    2|\n|           6885|         0.0245951|   8|    2|\n:::\n:::\n\n\nNow, lets merge. Note, \"By default the data frames are merged on the columns with names they both have\" therefore if I don't specify the by argument it will merge on all matching variables.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_all_long <- merge(df, df_new, all.x=T, all.y=T)\nstr(df_all_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t1287 obs. of  6 variables:\n $ observation_id   : int  5006 5006 5024 5024 5026 5026 5030 5030 5035 5035 ...\n $ IgG_concentration: num  155.581 164.298 0.292 0.3 0.254 ...\n $ age              : int  11 7 9 5 14 10 11 7 15 11 ...\n $ time             : num  2 1 2 1 2 1 2 1 2 1 ...\n $ gender           : chr  NA \"Male\" NA \"Female\" ...\n $ slum             : chr  NA \"Non slum\" NA \"Non slum\" ...\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(df_all_long)\n```\n\n::: {.cell-output-display}\n\n\n| observation_id| IgG_concentration| age| time|gender |slum     |\n|--------------:|-----------------:|---:|----:|:------|:--------|\n|           5006|       155.5811325|  11|    2|NA     |NA       |\n|           5006|       164.2979452|   7|    1|Male   |Non slum |\n|           5024|         0.2918605|   9|    2|NA     |NA       |\n|           5024|         0.3000000|   5|    1|Female |Non slum |\n|           5026|         0.2542945|  14|    2|NA     |NA       |\n|           5026|         0.3000000|  10|    1|Female |Non slum |\n:::\n:::\n\n\nNote, there are 1287 rows, which is the sum of the number of rows of `df` (651 rows) and `df_new` (636 rows)\n\nNotice that there are some missing values though, because `df_new` doesn't have\nthe `gender` or `slum` variables. If we assume that those are constant and\ndon't change between the two study points, we can fill in the data points\nbefore merging for an easy solution. One easy way to make a new dataframe from\n`df_new` with extra columns is to use the `transform()` function, which lets\nus make multiple column changes to a data frame at one time. We just\nneed to make sure to match the correct `observation_id` values together, using\nthe `match()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_new_filled <- transform(\n  df_new,\n  gender = df[match(df_new$observation_id, df$observation_id), \"gender\"],\n  slum = df[match(df_new$observation_id, df$observation_id), \"slum\"]\n)\n```\n:::\n\n\nNow we can redo the merge.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_all_long <- merge(df, df_new_filled, all.x=T, all.y=T)\nhead(df_all_long)\n```\n\n::: {.cell-output-display}\n\n\n| observation_id| IgG_concentration| age|gender |slum     | time|\n|--------------:|-----------------:|---:|:------|:--------|----:|\n|           5006|       155.5811325|  11|Male   |Non slum |    2|\n|           5006|       164.2979452|   7|Male   |Non slum |    1|\n|           5024|         0.2918605|   9|Female |Non slum |    2|\n|           5024|         0.3000000|   5|Female |Non slum |    1|\n|           5026|         0.2542945|  14|Female |Non slum |    2|\n|           5026|         0.3000000|  10|Female |Non slum |    1|\n:::\n:::\n\n\nLooks good now! Another solution would be to edit the data file, or use\na function that can actually fill in missing values for the same individual,\nlike `zoo::na.locf()`.\n\n## What is wide/long data?\n\nAbove, we actually created a wide and long version of the data.\n\nWide: has many columns\n\n- multiple columns per individual, values spread across multiple columns \n- easier for humans to read\n    \nLong: has many rows\n\n- column names become data\n- multiple rows per observation, a single column contains the values\n- easier for R to make plots & do analysis\n\n## `reshape()` function \n\nThe `reshape()` function allows you to toggle between wide and long data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?reshape\n```\n:::\n\nReshape Grouped Data\n\nDescription:\n\n     This function reshapes a data frame between 'wide' format (with\n     repeated measurements in separate columns of the same row) and\n     'long' format (with the repeated measurements in separate rows).\n\nUsage:\n\n     reshape(data, varying = NULL, v.names = NULL, timevar = \"time\",\n             idvar = \"id\", ids = 1:NROW(data),\n             times = seq_along(varying[[1]]),\n             drop = NULL, direction, new.row.names = NULL,\n             sep = \".\",\n             split = if (sep == \"\") {\n                 list(regexp = \"[A-Za-z][0-9]\", include = TRUE)\n             } else {\n                 list(regexp = sep, include = FALSE, fixed = TRUE)}\n             )\n     \n     ### Typical usage for converting from long to wide format:\n     \n     # reshape(data, direction = \"wide\",\n     #         idvar = \"___\", timevar = \"___\", # mandatory\n     #         v.names = c(___),    # time-varying variables\n     #         varying = list(___)) # auto-generated if missing\n     \n     ### Typical usage for converting from wide to long format:\n     \n     ### If names of wide-format variables are in a 'nice' format\n     \n     # reshape(data, direction = \"long\",\n     #         varying = c(___), # vector \n     #         sep)              # to help guess 'v.names' and 'times'\n     \n     ### To specify long-format variable names explicitly\n     \n     # reshape(data, direction = \"long\",\n     #         varying = ___,  # list / matrix / vector (use with care)\n     #         v.names = ___,  # vector of variable names in long format\n     #         timevar, times, # name / values of constructed time variable\n     #         idvar, ids)     # name / values of constructed id variable\n     \nArguments:\n\n    data: a data frame\n\n varying: names of sets of variables in the wide format that correspond\n          to single variables in long format ('time-varying').  This is\n          canonically a list of vectors of variable names, but it can\n          optionally be a matrix of names, or a single vector of names.\n          In each case, when 'direction = \"long\"', the names can be\n          replaced by indices which are interpreted as referring to\n          'names(data)'.  See 'Details' for more details and options.\n\n v.names: names of variables in the long format that correspond to\n          multiple variables in the wide format.  See 'Details'.\n\n timevar: the variable in long format that differentiates multiple\n          records from the same group or individual.  If more than one\n          record matches, the first will be taken (with a warning).\n\n   idvar: Names of one or more variables in long format that identify\n          multiple records from the same group/individual.  These\n          variables may also be present in wide format.\n\n     ids: the values to use for a newly created 'idvar' variable in\n          long format.\n\n   times: the values to use for a newly created 'timevar' variable in\n          long format.  See 'Details'.\n\n    drop: a vector of names of variables to drop before reshaping.\n\ndirection: character string, partially matched to either '\"wide\"' to\n          reshape to wide format, or '\"long\"' to reshape to long\n          format.\n\nnew.row.names: character or 'NULL': a non-null value will be used for\n          the row names of the result.\n\n     sep: A character vector of length 1, indicating a separating\n          character in the variable names in the wide format.  This is\n          used for guessing 'v.names' and 'times' arguments based on\n          the names in 'varying'.  If 'sep == \"\"', the split is just\n          before the first numeral that follows an alphabetic\n          character.  This is also used to create variable names when\n          reshaping to wide format.\n\n   split: A list with three components, 'regexp', 'include', and\n          (optionally) 'fixed'.  This allows an extended interface to\n          variable name splitting.  See 'Details'.\n\nDetails:\n\n     Although 'reshape()' can be used in a variety of contexts, the\n     motivating application is data from longitudinal studies, and the\n     arguments of this function are named and described in those terms.\n     A longitudinal study is characterized by repeated measurements of\n     the same variable(s), e.g., height and weight, on each unit being\n     studied (e.g., individual persons) at different time points (which\n     are assumed to be the same for all units). These variables are\n     called time-varying variables. The study may include other\n     variables that are measured only once for each unit and do not\n     vary with time (e.g., gender and race); these are called\n     time-constant variables.\n\n     A 'wide' format representation of a longitudinal dataset will have\n     one record (row) for each unit, typically with some time-constant\n     variables that occupy single columns, and some time-varying\n     variables that occupy multiple columns (one column for each time\n     point).  A 'long' format representation of the same dataset will\n     have multiple records (rows) for each individual, with the\n     time-constant variables being constant across these records and\n     the time-varying variables varying across the records.  The 'long'\n     format dataset will have two additional variables: a 'time'\n     variable identifying which time point each record comes from, and\n     an 'id' variable showing which records refer to the same unit.\n\n     The type of conversion (long to wide or wide to long) is\n     determined by the 'direction' argument, which is mandatory unless\n     the 'data' argument is the result of a previous call to 'reshape'.\n     In that case, the operation can be reversed simply using\n     'reshape(data)' (the other arguments are stored as attributes on\n     the data frame).\n\n     Conversion from long to wide format with 'direction = \"wide\"' is\n     the simpler operation, and is mainly useful in the context of\n     multivariate analysis where data is often expected as a\n     wide-format matrix. In this case, the time variable 'timevar' and\n     id variable 'idvar' must be specified. All other variables are\n     assumed to be time-varying, unless the time-varying variables are\n     explicitly specified via the 'v.names' argument.  A warning is\n     issued if time-constant variables are not actually constant.\n\n     Each time-varying variable is expanded into multiple variables in\n     the wide format.  The names of these expanded variables are\n     generated automatically, unless they are specified as the\n     'varying' argument in the form of a list (or matrix) with one\n     component (or row) for each time-varying variable. If 'varying' is\n     a vector of names, it is implicitly converted into a matrix, with\n     one row for each time-varying variable. Use this option with care\n     if there are multiple time-varying variables, as the ordering (by\n     column, the default in the 'matrix' constructor) may be\n     unintuitive, whereas the explicit list or matrix form is\n     unambiguous.\n\n     Conversion from wide to long with 'direction = \"long\"' is the more\n     common operation as most (univariate) statistical modeling\n     functions expect data in the long format. In the simpler case\n     where there is only one time-varying variable, the corresponding\n     columns in the wide format input can be specified as the 'varying'\n     argument, which can be either a vector of column names or the\n     corresponding column indices. The name of the corresponding\n     variable in the long format output combining these columns can be\n     optionally specified as the 'v.names' argument, and the name of\n     the time variables as the 'timevar' argument. The values to use as\n     the time values corresponding to the different columns in the wide\n     format can be specified as the 'times' argument.  If 'v.names' is\n     unspecified, the function will attempt to guess 'v.names' and\n     'times' from 'varying' (an explicitly specified 'times' argument\n     is unused in that case).  The default expects variable names like\n     'x.1', 'x.2', where 'sep = \".\"' specifies to split at the dot and\n     drop it from the name.  To have alphabetic followed by numeric\n     times use 'sep = \"\"'.\n\n     Multiple time-varying variables can be specified in two ways,\n     either with 'varying' as an atomic vector as above, or as a list\n     (or a matrix). The first form is useful (and mandatory) if the\n     automatic variable name splitting as described above is used; this\n     requires the names of all time-varying variables to be suitably\n     formatted in the same manner, and 'v.names' to be unspecified. If\n     'varying' is a list (with one component for each time-varying\n     variable) or a matrix (one row for each time-varying variable),\n     variable name splitting is not attempted, and 'v.names' and\n     'times' will generally need to be specified, although they will\n     default to, respectively, the first variable name in each set, and\n     sequential times.\n\n     Also, guessing is not attempted if 'v.names' is given explicitly,\n     even if 'varying' is an atomic vector. In that case, the number of\n     time-varying variables is taken to be the length of 'v.names', and\n     'varying' is implicitly converted into a matrix, with one row for\n     each time-varying variable. As in the case of long to wide\n     conversion, the matrix is filled up by column, so careful\n     attention needs to be paid to the order of variable names (or\n     indices) in 'varying', which is taken to be like 'x.1', 'y.1',\n     'x.2', 'y.2' (i.e., variables corresponding to the same time point\n     need to be grouped together).\n\n     The 'split' argument should not usually be necessary.  The\n     'split$regexp' component is passed to either 'strsplit' or\n     'regexpr', where the latter is used if 'split$include' is 'TRUE',\n     in which case the splitting occurs after the first character of\n     the matched string.  In the 'strsplit' case, the separator is not\n     included in the result, and it is possible to specify fixed-string\n     matching using 'split$fixed'.\n\nValue:\n\n     The reshaped data frame with added attributes to simplify\n     reshaping back to the original form.\n\nSee Also:\n\n     'stack', 'aperm'; 'relist' for reshaping the result of 'unlist'.\n     'xtabs' and 'as.data.frame.table' for creating contingency tables\n     and converting them back to data frames.\n\nExamples:\n\n     summary(Indometh) # data in long format\n     \n     ## long to wide (direction = \"wide\") requires idvar and timevar at a minimum\n     reshape(Indometh, direction = \"wide\", idvar = \"Subject\", timevar = \"time\")\n     \n     ## can also explicitly specify name of combined variable\n     wide <- reshape(Indometh, direction = \"wide\", idvar = \"Subject\",\n                     timevar = \"time\", v.names = \"conc\", sep= \"_\")\n     wide\n     \n     ## reverse transformation\n     reshape(wide, direction = \"long\")\n     reshape(wide, idvar = \"Subject\", varying = list(2:12),\n             v.names = \"conc\", direction = \"long\")\n     \n     ## times need not be numeric\n     df <- data.frame(id = rep(1:4, rep(2,4)),\n                      visit = I(rep(c(\"Before\",\"After\"), 4)),\n                      x = rnorm(4), y = runif(4))\n     df\n     reshape(df, timevar = \"visit\", idvar = \"id\", direction = \"wide\")\n     ## warns that y is really varying\n     reshape(df, timevar = \"visit\", idvar = \"id\", direction = \"wide\", v.names = \"x\")\n     \n     \n     ##  unbalanced 'long' data leads to NA fill in 'wide' form\n     df2 <- df[1:7, ]\n     df2\n     reshape(df2, timevar = \"visit\", idvar = \"id\", direction = \"wide\")\n     \n     ## Alternative regular expressions for guessing names\n     df3 <- data.frame(id = 1:4, age = c(40,50,60,50), dose1 = c(1,2,1,2),\n                       dose2 = c(2,1,2,1), dose4 = c(3,3,3,3))\n     reshape(df3, direction = \"long\", varying = 3:5, sep = \"\")\n     \n     \n     ## an example that isn't longitudinal data\n     state.x77 <- as.data.frame(state.x77)\n     long <- reshape(state.x77, idvar = \"state\", ids = row.names(state.x77),\n                     times = names(state.x77), timevar = \"Characteristic\",\n                     varying = list(names(state.x77)), direction = \"long\")\n     \n     reshape(long, direction = \"wide\")\n     \n     reshape(long, direction = \"wide\", new.row.names = unique(long$state))\n     \n     ## multiple id variables\n     df3 <- data.frame(school = rep(1:3, each = 4), class = rep(9:10, 6),\n                       time = rep(c(1,1,2,2), 3), score = rnorm(12))\n     wide <- reshape(df3, idvar = c(\"school\", \"class\"), direction = \"wide\")\n     wide\n     ## transform back\n     reshape(wide)\n\n\n\n## wide to long data\n\nReminder: \"typical usage for converting from long to wide format\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### If names of wide-format variables are in a 'nice' format\n\nreshape(data, direction = \"long\",\n       varying = c(___), # vector \n       sep)              # to help guess 'v.names' and 'times'\n\n### To specify long-format variable names explicitly\n\nreshape(data, direction = \"long\",\n       varying = ___,  # list / matrix / vector (use with care)\n       v.names = ___,  # vector of variable names in long format\n       timevar, times, # name / values of constructed time variable\n       idvar, ids)     # name / values of constructed id variable\n```\n:::\n\n\nWe can try to apply that to our data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_wide_to_long <-\n  reshape(\n    # First argument is the wide-format data frame to be reshaped\n    df_all_wide,\n    # We are inputting wide data and expect long format as output\n    direction = \"long\",\n    # \"varying\" argument is a list of vectors. Each vector in the list is a\n    # group of time-varying (or grouping-factor-varying) variables which\n    # should become one variable after reformat. We want two variables after\n    # reformating, so we need two vectors in a list.\n    varying = list(\n      c(\"IgG_concentration_time1\", \"IgG_concentration_time2\"),\n      c(\"age_time1\", \"age_time2\")\n    ),\n    # \"v.names\" is a vector of names for the new long-format variables, it\n    # should have the same length as the list for varying and the names will\n    # be assigned in order.\n    v.names = c(\"IgG_concentration\", \"age\"),\n    # Name of the variable for the time index that will be created\n    timevar = \"time\",\n    # Values of the time variable that should be created. Note that if you\n    # have any missing observations over time, they NEED to be in the dataset\n    # as NAs or your times will get messed up.\n    times = 1:2,\n    # 'idvar' is a variable that marks which records belong to each\n    # observational unit, for us that is the ID marking individuals.\n    idvar = \"observation_id\"\n  )\n```\n:::\n\n\nNotice that this has exactly twice as many rows as our wide data format, and\ndoesn't appear to have any systematic missingness, so it seems correct.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df_wide_to_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t1302 obs. of  6 variables:\n $ observation_id   : int  5006 5024 5026 5030 5035 5054 5057 5063 5064 5080 ...\n $ gender           : chr  \"Male\" \"Female\" \"Female\" \"Female\" ...\n $ slum             : chr  \"Non slum\" \"Non slum\" \"Non slum\" \"Non slum\" ...\n $ time             : int  1 1 1 1 1 1 1 1 1 1 ...\n $ IgG_concentration: num  164.2979 0.3 0.3 0.0556 26.2113 ...\n $ age              : int  7 5 10 7 11 3 3 12 14 6 ...\n - attr(*, \"reshapeLong\")=List of 4\n  ..$ varying:List of 2\n  .. ..$ : chr [1:2] \"IgG_concentration_time1\" \"IgG_concentration_time2\"\n  .. ..$ : chr [1:2] \"age_time1\" \"age_time2\"\n  ..$ v.names: chr [1:2] \"IgG_concentration\" \"age\"\n  ..$ idvar  : chr \"observation_id\"\n  ..$ timevar: chr \"time\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(df_wide_to_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1302\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(df_all_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 651\n```\n\n\n:::\n:::\n\n\n## long to wide data\n\nReminder: \"typical usage for converting from long to wide format\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreshape(data, direction = \"wide\",\n       idvar = \"___\", timevar = \"___\", # mandatory\n       v.names = c(___),    # time-varying variables\n       varying = list(___)) # auto-generated if missing\n```\n:::\n\n\nWe can try to apply that to our data. Note that the arguments are the same\nas in the wide to long case, but we don't need to specify the `times` argument\nbecause they are in the data already. The `varying` argument is optional also,\nand R will auto-generate names for the wide variables if it is left empty.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long_to_wide <-\n  reshape(\n    df_all_long,\n    direction = \"wide\",\n    idvar = \"observation_id\",\n    timevar = \"time\",\n    v.names = c(\"IgG_concentration\", \"age\"),\n    varying = list(\n      c(\"IgG_concentration_time1\", \"IgG_concentration_time2\"),\n      c(\"age_time1\", \"age_time2\")\n    )\n  )\n```\n:::\n\n\nWe can do the same checks to make sure we pivoted correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df_long_to_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t651 obs. of  7 variables:\n $ observation_id         : int  5006 5024 5026 5030 5035 5054 5057 5063 5064 5080 ...\n $ gender                 : chr  \"Male\" \"Female\" \"Female\" \"Female\" ...\n $ slum                   : chr  \"Non slum\" \"Non slum\" \"Non slum\" \"Non slum\" ...\n $ IgG_concentration_time1: num  155.5811 0.2919 0.2543 0.0533 22.0159 ...\n $ age_time1              : int  11 9 14 11 15 7 7 16 18 10 ...\n $ IgG_concentration_time2: num  164.2979 0.3 0.3 0.0556 26.2113 ...\n $ age_time2              : int  7 5 10 7 11 3 3 12 14 6 ...\n - attr(*, \"reshapeWide\")=List of 5\n  ..$ v.names: chr [1:2] \"IgG_concentration\" \"age\"\n  ..$ timevar: chr \"time\"\n  ..$ idvar  : chr \"observation_id\"\n  ..$ times  : num [1:2] 2 1\n  ..$ varying: chr [1:2, 1:2] \"IgG_concentration_time1\" \"age_time1\" \"IgG_concentration_time2\" \"age_time2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(df_long_to_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 651\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(df_all_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1287\n```\n\n\n:::\n:::\n\n\nNote that this time we don't have exactly twice as many records because of some\nquirks in how `reshape()` works. When we go from wide to long, R will create\nnew records with NA values at the second time point for the individuals who\nwere not in the second study -- it won't do that when we go from long to\nwide data. This is why it can be important to make sure all of your\nmissing data are **explicit** rather than **implicit**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For the original long dataset, we can see that not all individuals have 2\n# time points\nall(table(df_all_long$observation_id) == 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# But for the reshaped version they do all have 2 time points\nall(table(df_wide_to_long$observation_id) == 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n## `reshape` metadata\n\nWhenever you use `reshape()` to change the data format, it leaves behind some\nmetadata on our new data frame, as an `attr`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(df_wide_to_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t1302 obs. of  6 variables:\n $ observation_id   : int  5006 5024 5026 5030 5035 5054 5057 5063 5064 5080 ...\n $ gender           : chr  \"Male\" \"Female\" \"Female\" \"Female\" ...\n $ slum             : chr  \"Non slum\" \"Non slum\" \"Non slum\" \"Non slum\" ...\n $ time             : int  1 1 1 1 1 1 1 1 1 1 ...\n $ IgG_concentration: num  164.2979 0.3 0.3 0.0556 26.2113 ...\n $ age              : int  7 5 10 7 11 3 3 12 14 6 ...\n - attr(*, \"reshapeLong\")=List of 4\n  ..$ varying:List of 2\n  .. ..$ : chr [1:2] \"IgG_concentration_time1\" \"IgG_concentration_time2\"\n  .. ..$ : chr [1:2] \"age_time1\" \"age_time2\"\n  ..$ v.names: chr [1:2] \"IgG_concentration\" \"age\"\n  ..$ idvar  : chr \"observation_id\"\n  ..$ timevar: chr \"time\"\n```\n\n\n:::\n:::\n\n\nThis stores information so we can `reshape()` back to the other format and\nwe don't have to specify arguments again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_back_to_wide <- reshape(df_wide_to_long)\n```\n:::\n\n\n## Let's get real\n\nWe recommend checking out the `pivot_wider()` and `pivot_longer()` from the tidyr package!\n\n\n\n## Summary\n\n- the `merge()` function can be used to merge datasets. \n- pay close attention to the number of rows in your data set before and after a merge\n- wide data has many columns per observation\n- long data has many rows per observation\n- the `reshape()`function allows you to toggle between wide and long data. although we highly recommend playing around with the `pivot_wider()` and `pivot_longer()` from the tidyr package instead \n\t\t\n\n## Acknowledgements\n\nThese are the materials we looked through, modified, or extracted to complete this module's lecture.\n\n-   [\"Introduction to R for Public Health Researchers\" Johns Hopkins University](https://jhudatascience.org/intro_to_r/)\n\n",
    "supporting": [
      "Module08-DataMergeReshape_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}