{
  "hash": "6801b741f7bacc1d7d4e3e6716cfd447",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 4: Functions\"\nformat: \n  revealjs:\n    scrollable: true\n    toc: false\n---\n\n\n\n\n## Learning Objectives\n\nAfter module XX, you should be able to:\n\n- Name the parts of a function\n- Write a function\n- Use the R/RStudio debugging tools for functions\n\n## Writing your own functions\n\n**why create your own function?**\n\n1. to cut down on repetitive coding\n2. to organize code into manageable chunks\n3. to avoid running code unintentionally\n4. to use names that make sense to you\n\n## Writing your own functions\n\nHere we will write a function that multiplies some number (x) by 2:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimes_2 <- function(x) x*2\n```\n:::\n\n\n\nWhen you run the line of code above, you make it ready to use (no output yet!)\nLet's test it!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimes_2(x=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\n\n\n## Writing your own functions: { }\n\nAdding the curly brackets - `{ }` - allows you to use functions spanning multiple lines:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimes_3 <- function(x) {\n  x*3\n}\ntimes_3(x=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30\n```\n\n\n:::\n:::\n\n\n\n\n## Writing your own functions: `return`\n\nIf we want something specific for the function's output, we use `return()`. Note, if you want to return more than one object, you need to put it into a list using the `list()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimes_4 <- function(x) {\n  output <- x * 4\n  return(list(output, x))\n}\ntimes_4(x = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 40\n\n[[2]]\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n\n- R will \"implicitly\" return the last evaluated expression by default. \n- You should get in the habit of using \"explicit\" return statements so that you don't get unexpected output.\n\n## Function Syntax\n\nThis is a brief introduction. The syntax is:\n\n```\nfunctionName = function(inputs) {\n< function body >\nreturn(list(value1, value2))\n}\n```\n\nNote to create the function for use you need to \n\n1. Code/type the function\n2. Execute/run the lines of code\n\nOnly then will the function be available in the Environment pane and ready to use.\n\n## Writing your own functions: multiple arguments\n\nFunctions can take multiple arguments / inputs. Here the function has two arguments `x` and `y`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimes_2_plus_y <- function(x, y) {\n  out <- x * 2 + y\n  return(out)\n}\ntimes_2_plus_y(x = 10, y = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23\n```\n\n\n:::\n:::\n\n\n\n\n## Writing your own functions: arugment defaults\n\nFunctions can have default arguments. This lets us use the function without specifying the arguments\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntimes_2_plus_y <- function(x = 10, y = 3) {\n  out <- x * 2 + y\n  return(out)\n}\ntimes_2_plus_y()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23\n```\n\n\n:::\n:::\n\n\n\n\nWe got an answer b/c we put defaults into the function arguments.\n\n## Writing a simple function\n\nLet's write a function, `sqdif`, that:\n\n1. takes two numbers `x` and `y` with default values of 2 and 3.\n2. takes the difference\n3. squares this difference\n4. then returns the final value\n\n```\nfunctionName = function(inputs) {\n< function body >\nreturn(list(value1, value2))\n}\n```\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqdif <- function(x=2,y=3){\n     output <- (x-y)^2\n     return(output)\n}\n\nsqdif()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nsqdif(x=10,y=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n\n```{.r .cell-code}\nsqdif(10,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n* Note that this function is implicitly vectorized even if we didn't mean for it to be.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqdif(c(2, 3, 4), c(7, 3.14, 98))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   25.0000    0.0196 8836.0000\n```\n\n\n:::\n:::\n\n\n\n\n## Writing your own functions: characters\n\nFunctions can have any kind of data type input. For example, here is a function with characters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloud <- function(word) {\n  output <- rep(toupper(word), 5)\n  return(output)\n}\nloud(word = \"hooray!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"HOORAY!\" \"HOORAY!\" \"HOORAY!\" \"HOORAY!\" \"HOORAY!\"\n```\n\n\n:::\n:::\n\n\n\n\n## The `...` (elipsis) argument {.incremental}\n\n* What if we want our function to take in an arbitrary amount of numbers?\n* As an example, let's consider a function that calculates the **geometric mean**.\n\n$$\n\\text{geometric mean}(\\mathbf{x}) = \\sqrt[n]{x_1 \\cdot x_2 \\cdot \\ldots \\cdot x_n} = \\exp\\left( \\frac{1}{n}\\left(\\log x_1 + \\ldots + \\log x_n \\right) \\right)\n$$\n\n* We can do this on a vector, of course.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo_mean <- function(x) {\n\toutput <- exp(mean(log(x)))\n\treturn(output)\n}\n\ngeo_mean(c(2, 3, 4, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.309751\n```\n\n\n:::\n:::\n\n\n\n\n## The `...` (elipsis) argument {.incremental}\n\n* But sometimes it's easier to write this a different way.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo_mean <- function(...) {\n\tx <- c(...)\n\toutput <- exp(mean(log(x)))\n\treturn(output)\n}\n\ngeo_mean(2, 3, 4, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.309751\n```\n\n\n:::\n:::\n\n\n\n\n* `...` is a placeholder for as many arguments as you want.\n\n## `...` for pass-through {.scrollable}\n\n* The most common use of `...` is to \"pass-through\" arguments to underlying functions.\n\n* `mean()` has additional arguments, what if we want to use those in our geometric mean calculation?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo_mean <- function(x, trim = 0, na.rm = FALSE) {\n\t\toutput <- exp(mean(log(x), trim = trim, na.rm = na.rm))\n\treturn(output)\n}\n```\n:::\n\n\n\n\n. . .\n\nOr we can do this an easier way.\n\n## Function debugging tools if you get stuck\n\n- `traceback()`\n- `browser()`\n- `debug()` and `debugonce()`\n- RStudio breakpoints\n- **Last resort:** printing and dumping\n- More info: [https://adv-r.hadley.nz/debugging.html](https://adv-r.hadley.nz/debugging.html)\n\n## Function instead of Loop {.scrollable}\n\nNow, let's see how we can repeat our loop example from the measles dataset with a function instead.\n\nHere we are going to set up a function that takes our data frame and outputs the median, first and third quartiles, and range of measles cases for a specified country.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_country_stats <- function(df, iso3_code){\n\t\n\tcountry_data <- subset(df, iso3c == iso3_code)\n\t\n\t# Get the summary statistics for this country\n\tcountry_cases <- country_data$measles_cases\n\tcountry_quart <- quantile(\n\t\tcountry_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n\t)\n\tcountry_range <- range(country_cases, na.rm = TRUE)\n\t\n\tcountry_name <- unique(country_data$country)\n\t\n\tcountry_summary <- data.frame(\n\t\tcountry = country_name,\n\t\tmin = country_range[[1]],\n\t\tQ1 = country_quart[[1]],\n\t\tmedian = country_quart[[2]],\n\t\tQ3 = country_quart[[3]],\n\t\tmax = country_range[[2]]\n\t)\n\t\n\treturn(country_summary)\n}\n```\n:::\n\n\n\n\nNow we can use the function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeas <- readRDS(here::here(\"data\", \"measles_final.Rds\"))\nget_country_stats(df=meas, iso3_code=\"IND\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  country  min      Q1  median       Q3    max\n1   India 3305 31135.5 47109.5 80797.25 252940\n```\n\n\n:::\n\n```{.r .cell-code}\nget_country_stats(df=meas, iso3_code=\"PAK\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   country min     Q1 median    Q3   max\n1 Pakistan 386 2065.5 4075.5 17422 55543\n```\n\n\n:::\n:::\n\n\n\n\n\n## Summary\n\n- Simple functions take the form:\n```\nfunctionName = function(arguments) {\n\t< function body >\n\treturn(list(outputs))\n}\n```\n- We can specify arguments defaults when you create the function\n\n\n## You try it!\n\nCreate your own function that calculates the incidence rate per $K$ cases in a given country for all years where that country appeared (e.g. incidence per 10,000 people or another number $K$).\n\nStep 1. Determine your arguments.\n\nStep 2. Begin your function by subsetting the data to include only the country specified in the arguments (i.e, `country_data`).\n\nStep 3. Get the years of interest (what errors might you run into here?).\n\nStep 4. Calculate the incidence rate per $K$ people in each year.\n\nStep 5. Return the output neatly.\n\n**Bonus exercise:** allow the country code argument to be optional, or add a new argument that allows the user to only calculate the incidence for certain years.\n\n## Mini Exercise Answer\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_incidence <- function(df, iso3_code, K = 10000){\n\t\n\tcountry_data <- subset(df, iso3c == iso3_code)\n\t\n\tincidence <- country_data$measles_cases / country_data$population * K\n\tnames(incidence) <- country_data$year\n\t\n\treturn(incidence)\n}\n\nget_incidence(df=meas, iso3_code=\"IND\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      2023       2022       2021       2020       2019       2018       2017 \n0.45603205 0.28907547 0.04049550 0.04013214 0.07540965 0.14224947 0.08884979 \n      2016       2015       2014       2013       2012       2011       2010 \n0.12886248 0.22805022 0.20294566 0.06416849 0.02593200 0.26744142 0.25356807 \n      2009       2008       2007       2006       2005       2004       2003 \n0.45918728 0.36675830 0.34583747 0.54747898 0.31794361 0.48794093 0.42192914 \n      2002       2001       2000       1999       1998       1997       1996 \n0.36459551 0.47990173 0.36649458 0.20195097 0.33276727 0.60861874 0.47872368 \n      1995       1994       1993       1992       1991       1990       1989 \n0.38882932 0.53443386 0.54397290 0.79109798 0.87586166 1.02948793 1.94564007 \n      1988       1987       1986       1985       1984       1983       1982 \n1.93562738 3.10083364 1.94360299 2.06623051 2.50206072 1.73819235 2.00496602 \n      1981       1980 \n2.83437652 1.63650050 \n```\n\n\n:::\n\n```{.r .cell-code}\nget_incidence(df=meas, iso3_code=\"PAK\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      2023       2022       2021       2020       2019       2018       2017 \n0.73692544 0.35526364 0.44939088 0.12090842 0.09252406 1.50215163 0.42402323 \n      2016       2015       2014       2013       2012       2011       2010 \n0.12658949 0.01829650 0.06578580 0.42607889 0.39791131 0.22084288 0.22221137 \n      2009       2008       2007       2006       2005       2004       2003 \n0.04539161 0.06072114 0.15396495 0.42910095 0.17095625 0.24893257 0.28404208 \n      2002       2001       2000       1999       1998       1997       1996 \n0.23906241 0.24174444 0.13370480 0.19640005 0.16036998 0.13075755 0.07942591 \n      1995       1994       1993       1992       1991       1990       1989 \n0.12920918 0.10994611 0.15667487 0.24245113 0.05176020 1.88755151 0.21035120 \n      1988       1987       1986       1985       1984       1983       1982 \n5.14440235 4.41204007 4.20439485 2.74769085 1.84269015 2.30609510 2.26464854 \n      1981       1980 \n3.44249798 3.54397944 \n```\n\n\n:::\n:::\n\n\n\n\n## Sidenote: combining functions and loops {.scrollable}\n\n- Writing functions is a way to make complex code a lot easier to understand.\n- These two loops do exactly the same thing, but the one with the function is much easier to read for most people.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_countries <- c(\"IND\", \"PAK\", \"BGD\", \"NPL\", \"BTN\")\nn <- length(my_countries)\nres <- vector(mode = \"list\", length = n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:n) {\n\tthis_country <- my_countries[[i]]\n\tcountry_data <- subset(meas, iso3c == this_country)\n\tincidence <- country_data$measles_cases / country_data$population * 10000\n\tnames(incidence) <- country_data$year\n\tres[[i]] <- incidence\n}\nstr(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ : Named num [1:44] 0.456 0.2891 0.0405 0.0401 0.0754 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.7369 0.3553 0.4494 0.1209 0.0925 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.0162 0.0182 0.012 0.1439 0.3521 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.3117 0.0426 0.0476 0.1322 0.1491 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.127 0.0895 NA NA 0.0261 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:n) {\n\tres[[i]] <- get_incidence(meas, my_countries[[i]], 10000)\n}\nstr(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ : Named num [1:44] 0.456 0.2891 0.0405 0.0401 0.0754 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.7369 0.3553 0.4494 0.1209 0.0925 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.0162 0.0182 0.012 0.1439 0.3521 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.3117 0.0426 0.0476 0.1322 0.1491 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n $ : Named num [1:44] 0.127 0.0895 NA NA 0.0261 ...\n  ..- attr(*, \"names\")= chr [1:44] \"2023\" \"2022\" \"2021\" \"2020\" ...\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}