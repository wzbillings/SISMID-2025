{
  "hash": "219f056618b943630a88b5d8b9278252",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 7: Variable Creation, Classes, and Summaries\"\nformat:\n  revealjs:\n    smaller: true\n    scrollable: true\n    toc: false\n---\n\n\n\n\n## Learning Objectives\n\nAfter module 7, you should be able to...\n\n-   Create new variables\n-   Characterize variable classes\n-   Manipulate the classes of variables\n-   Conduct 1 variable data summaries\n\n## Import data for this module\nLet's first read in the data from the previous module and look at it briefly with a new function `head()`. `head()` allows us to look at the first `n` observations.\n\n\n\n\n\n::: {.cell layout-align=\"left\"}\n::: {.cell-output-display}\n![](images/head_args.png){fig-align='left' width=100%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read.csv(file = \"data/serodata.csv\") #relative path\nhead(x=df, n=3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  observation_id IgG_concentration age gender     slum\n1           5772         0.3176895   2 Female Non slum\n2           8095         3.4368231   4 Female Non slum\n3           9784         0.3000000   4   Male Non slum\n```\n\n\n:::\n:::\n\n\n\n\n\n## Adding new columns with `$` operator\n\nYou can add a new column, called `log_IgG` to `df`, using the `$` operator:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$log_IgG <- log(df$IgG_concentration)\nhead(df,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  observation_id IgG_concentration age gender     slum   log_IgG\n1           5772         0.3176895   2 Female Non slum -1.146681\n2           8095         3.4368231   4 Female Non slum  1.234548\n3           9784         0.3000000   4   Male Non slum -1.203973\n```\n\n\n:::\n:::\n\n\n\n\nNote, my use of the underscore in the variable name rather than a space.  This is good coding practice and make calling variables much less prone to error.\n\n## Adding new columns with `transform()`\n\nWe can also add a new column using the `transform()` function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?transform\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 method overwritten by 'printr':\n  method                from     \n  knit_print.data.frame rmarkdown\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTransform an Object, for Example a Data Frame\n\nDescription:\n\n     'transform' is a generic function, which-at least currently-only\n     does anything useful with data frames.  'transform.default'\n     converts its first argument to a data frame if possible and calls\n     'transform.data.frame'.\n\nUsage:\n\n     transform(`_data`, ...)\n     \nArguments:\n\n   _data: The object to be transformed\n\n     ...: Further arguments of the form 'tag=value'\n\nDetails:\n\n     The '...' arguments to 'transform.data.frame' are tagged vector\n     expressions, which are evaluated in the data frame '_data'.  The\n     tags are matched against 'names(_data)', and for those that match,\n     the value replace the corresponding variable in '_data', and the\n     others are appended to '_data'.\n\nValue:\n\n     The modified value of '_data'.\n\nWarning:\n\n     This is a convenience function intended for use interactively.\n     For programming it is better to use the standard subsetting\n     arithmetic functions, and in particular the non-standard\n     evaluation of argument 'transform' can have unanticipated\n     consequences.\n\nNote:\n\n     If some of the values are not vectors of the appropriate length,\n     you deserve whatever you get!\n\nAuthor(s):\n\n     Peter Dalgaard\n\nSee Also:\n\n     'within' for a more flexible approach, 'subset', 'list',\n     'data.frame'\n\nExamples:\n\n     transform(airquality, Ozone = -Ozone)\n     transform(airquality, new = -Ozone, Temp = (Temp-32)/1.8)\n     \n     attach(airquality)\n     transform(Ozone, logOzone = log(Ozone)) # marginally interesting ...\n     detach(airquality)\n```\n\n\n:::\n:::\n\n\n\n\n## Adding new columns with `transform()`\n\nFor example, adding a binary column for seropositivity called `seropos`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- transform(df, seropos = IgG_concentration >= 10)\nhead(df)\n```\n\n::: {.cell-output-display}\n\n\n| observation_id| IgG_concentration| age|gender |slum     |    log_IgG|seropos |\n|--------------:|-----------------:|---:|:------|:--------|----------:|:-------|\n|           5772|         0.3176895|   2|Female |Non slum | -1.1466807|FALSE   |\n|           8095|         3.4368231|   4|Female |Non slum |  1.2345475|FALSE   |\n|           9784|         0.3000000|   4|Male   |Non slum | -1.2039728|FALSE   |\n|           9338|       143.2363014|   4|Male   |Non slum |  4.9644957|TRUE    |\n|           6369|         0.4476534|   1|Male   |Non slum | -0.8037359|FALSE   |\n|           6885|         0.0252708|   4|Male   |Non slum | -3.6781074|FALSE   |\n:::\n:::\n\n\n\n\n\n## Creating conditional variables\n\nOne frequently used tool is creating variables with conditions. A general function for creating new variables based on existing variables is the Base R `ifelse()` function, which \"returns a value depending on whether the element of test is `TRUE` or `FALSE` or `NA`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?ifelse\n```\n:::\n\nConditional Element Selection\n\nDescription:\n\n     'ifelse' returns a value with the same shape as 'test' which is\n     filled with elements selected from either 'yes' or 'no' depending\n     on whether the element of 'test' is 'TRUE' or 'FALSE'.\n\nUsage:\n\n     ifelse(test, yes, no)\n     \nArguments:\n\n    test: an object which can be coerced to logical mode.\n\n     yes: return values for true elements of 'test'.\n\n      no: return values for false elements of 'test'.\n\nDetails:\n\n     If 'yes' or 'no' are too short, their elements are recycled.\n     'yes' will be evaluated if and only if any element of 'test' is\n     true, and analogously for 'no'.\n\n     Missing values in 'test' give missing values in the result.\n\nValue:\n\n     A vector of the same length and attributes (including dimensions\n     and '\"class\"') as 'test' and data values from the values of 'yes'\n     or 'no'.  The mode of the answer will be coerced from logical to\n     accommodate first any values taken from 'yes' and then any values\n     taken from 'no'.\n\nWarning:\n\n     The mode of the result may depend on the value of 'test' (see the\n     examples), and the class attribute (see 'oldClass') of the result\n     is taken from 'test' and may be inappropriate for the values\n     selected from 'yes' and 'no'.\n\n     Sometimes it is better to use a construction such as\n\n       (tmp <- yes; tmp[!test] <- no[!test]; tmp)\n     \n     , possibly extended to handle missing values in 'test'.\n\n     Further note that 'if(test) yes else no' is much more efficient\n     and often much preferable to 'ifelse(test, yes, no)' whenever\n     'test' is a simple true/false result, i.e., when 'length(test) ==\n     1'.\n\n     The 'srcref' attribute of functions is handled specially: if\n     'test' is a simple true result and 'yes' evaluates to a function\n     with 'srcref' attribute, 'ifelse' returns 'yes' including its\n     attribute (the same applies to a false 'test' and 'no' argument).\n     This functionality is only for backwards compatibility, the form\n     'if(test) yes else no' should be used whenever 'yes' and 'no' are\n     functions.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'if'.\n\nExamples:\n\n     x <- c(6:-4)\n     sqrt(x)  #- gives warning\n     sqrt(ifelse(x >= 0, x, NA))  # no warning\n     \n     ## Note: the following also gives the warning !\n     ifelse(x >= 0, sqrt(x), NA)\n     \n     \n     ## ifelse() strips attributes\n     ## This is important when working with Dates and factors\n     x <- seq(as.Date(\"2000-02-29\"), as.Date(\"2004-10-04\"), by = \"1 month\")\n     ## has many \"yyyy-mm-29\", but a few \"yyyy-03-01\" in the non-leap years\n     y <- ifelse(as.POSIXlt(x)$mday == 29, x, NA)\n     head(y) # not what you expected ... ==> need restore the class attribute:\n     class(y) <- class(x)\n     y\n     ## This is a (not atypical) case where it is better *not* to use ifelse(),\n     ## but rather the more efficient and still clear:\n     y2 <- x\n     y2[as.POSIXlt(x)$mday != 29] <- NA\n     ## which gives the same as ifelse()+class() hack:\n     stopifnot(identical(y2, y))\n     \n     \n     ## example of different return modes (and 'test' alone determining length):\n     yes <- 1:3\n     no  <- pi^(1:4)\n     utils::str( ifelse(NA,    yes, no) ) # logical, length 1\n     utils::str( ifelse(TRUE,  yes, no) ) # integer, length 1\n     utils::str( ifelse(FALSE, yes, no) ) # double,  length 1\n\n\n\n\n\n## `ifelse` example\n\nReminder of the first three arguments in the `ifelse()` function are `ifelse(test, yes, no)`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group <- ifelse(df$age <= 5, \"young\", \"old\")\nhead(df)\n```\n\n::: {.cell-output-display}\n\n\n| observation_id| IgG_concentration| age|gender |slum     |    log_IgG|seropos |age_group |\n|--------------:|-----------------:|---:|:------|:--------|----------:|:-------|:---------|\n|           5772|         0.3176895|   2|Female |Non slum | -1.1466807|FALSE   |young     |\n|           8095|         3.4368231|   4|Female |Non slum |  1.2345475|FALSE   |young     |\n|           9784|         0.3000000|   4|Male   |Non slum | -1.2039728|FALSE   |young     |\n|           9338|       143.2363014|   4|Male   |Non slum |  4.9644957|TRUE    |young     |\n|           6369|         0.4476534|   1|Male   |Non slum | -0.8037359|FALSE   |young     |\n|           6885|         0.0252708|   4|Male   |Non slum | -3.6781074|FALSE   |young     |\n:::\n:::\n\n\n\n\n## `ifelse` example\nLet's delve into what is actually happening, with a focus on the NA values in `age` variable.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group <- ifelse(df$age <= 5, \"young\", \"old\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age <= 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE    NA  TRUE  TRUE  TRUE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE  TRUE  TRUE  TRUE    NA  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE    NA  TRUE  TRUE\n[121]    NA  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[145]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n[181]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[205]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[229]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[265]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[277] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[289]  TRUE    NA FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[313]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[325]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n[337] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[349] FALSE    NA FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[361]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[385]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[409]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[433]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE  TRUE  TRUE  TRUE  TRUE    NA    NA  TRUE  TRUE  TRUE  TRUE\n[457]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[481]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[493]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[517]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[541]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[565]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[589] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[613]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[637]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE    NA FALSE FALSE FALSE\n[649] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Nesting two `ifelse` statements example\n\n`ifelse(test1, yes_to_test1, ifelse(test2, no_to_test2_yes_to_test2, no_to_test1_no_to_test2))`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group <- ifelse(df$age <= 5, \"young\", \n                       ifelse(df$age<=10 & df$age>5, \"middle\", \"old\"))\n```\n:::\n\n\n\n\nLet's use the `table()` function to check if it worked.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df$age, df$age_group, useNA=\"always\", dnn=list(\"age\", \"\"))\n```\n\n::: {.cell-output-display}\n\n\n|age/ | middle| old| young| NA|\n|:----|------:|---:|-----:|--:|\n|1    |      0|   0|    44|  0|\n|2    |      0|   0|    72|  0|\n|3    |      0|   0|    79|  0|\n|4    |      0|   0|    80|  0|\n|5    |      0|   0|    41|  0|\n|6    |     38|   0|     0|  0|\n|7    |     38|   0|     0|  0|\n|8    |     39|   0|     0|  0|\n|9    |     20|   0|     0|  0|\n|10   |     44|   0|     0|  0|\n|11   |      0|  41|     0|  0|\n|12   |      0|  23|     0|  0|\n|13   |      0|  35|     0|  0|\n|14   |      0|  37|     0|  0|\n|15   |      0|  11|     0|  0|\n|NA   |      0|   0|     0|  9|\n:::\n:::\n\n\n\n\nNote, it puts the variable levels in alphabetical order, we will show how to change this later.\n\n# Data Classes\n\n## Overview - Data Classes\n\n1. One dimensional types (i.e., vectors of characters, numeric, logical, or factor values)\n\n2. Two dimensional types (e.g., matrix, data frame, tibble)\n\n3. Special data classes (e.g., lists, dates). \n\n## \t`class()` function\n\nThe `class()` function allows you to evaluate the class of an object.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(df$gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## One dimensional data types\n\n* Character: strings or individual characters, quoted\n* Numeric: any real number(s)\n    - Double: contains fractional values (i.e., double precision) - default numeric\n    - Integer: any integer(s)/whole numbers\n* Logical: variables composed of TRUE or FALSE\n* Factor: categorical/qualitative variables\n\n## Character and numeric\n\nThis can also be a bit tricky. \n\nIf only one character in the whole vector, the class is assumed to be character\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(1, 2, \"tree\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nHere because integers are in quotations, it is read as a character class by R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(\"1\", \"4\", \"7\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n\nNote, instead of creating a new vector object (e.g., `x <- c(\"1\", \"4\", \"7\")`) and then feeding the vector object `x` into the first argument of the `class()` function (e.g., `class(x)`), we combined the two steps and directly fed a vector object into the class function.\n\n## Numeric Subclasses\n\nThere are two major numeric subclasses\n\n1. `Double` is a special subset of `numeric` that contains <span style=\"color: red;\">fractional values</span>. `Double` stands for [double-precision](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n2. `Integer` is a special subset of `numeric` that contains only <span style=\"color: red;\">whole numbers</span>. \n\n`typeof()` identifies the vector type (double, integer, logical, or character), whereas `class()` identifies the root class. The difference between the two will be more clear when we look at two dimensional classes below.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Logical\n\nReminder `logical` is a type that only has three possible elements: `TRUE` and `FALSE` and `NA`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(c(TRUE, FALSE, TRUE, TRUE, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n\nNote that when creating `logical` object the `TRUE` and `FALSE` are NOT in quotes. Putting R special classes (e.g., `NA` or `FALSE`) in quotations turns them into character value. \n\n\n## Other useful functions for evaluating/setting classes\n\nThere are two useful functions associated with practically all R classes: \n\n- `is.CLASS_NAME(x)` to **logically check** whether or not `x` is of certain  class.  For example,  `is.integer` or `is.character` or `is.numeric`\n- `as.CLASS_NAME(x)` to **coerce between classes** `x` from current `x` class into a another class. For example, `as.integer` or `as.character` or `as.numeric`.  This is particularly useful is maybe integer variable was read in as a character variable, or when you need to change a character variable to a factor variable (more on this later).\n\n## Examples `is.CLASS_NAME(x)`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(df$IgG_concentration)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(df$gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n## Examples `as.CLASS_NAME(x)`\n\nIn some cases, coercing is seamless\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(c(1, 4, 7))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"4\" \"7\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"4\", \"7\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 4 7\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(c(\"TRUE\", \"FALSE\", \"FALSE\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nIn some cases the coercing is not possible; if executed, will return `NA`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(c(\"1\", \"4\", \"7a\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4 NA\n```\n\n\n:::\n\n```{.r .cell-code}\nas.logical(c(\"TRUE\", \"FALSE\", \"UNKNOWN\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE    NA\n```\n\n\n:::\n:::\n\n\n\n\n\n## Factors\n\nA `factor` is a special `character` vector where the elements have pre-defined groups or 'levels'. You can think of these as qualitative or categorical variables. Use the `factor()` function to create factors from character values. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df$age_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndf$age_group_factor <- factor(df$age_group)\nclass(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"middle\" \"old\"    \"young\" \n```\n\n\n:::\n:::\n\n\n\n\nNote 1, that levels are, by default, set to **alphanumerical** order! And, the first is always the \"reference\" group. However, we often prefer a different reference group.\n\nNote 2, we can also make ordered factors using `factor(... ordered=TRUE)`, but we won't talk more about that.\n\n## Reference Groups \n\n**Why do we care about reference groups?** \n\nGeneralized linear regression allows you to compare the outcome of two or more groups. Your reference group is the group that everything else is compared to. Say we want to assess whether being <5 years old is associated with higher IgG antibody concentrations \n\nBy default `middle` is the reference group therefore we will only generate beta coefficients comparing `middle` to `young` AND `middle` to `old`.  But, we want `young` to be the reference group so we will generate beta coefficients comparing `young` to `middle` AND `young` to `old`.\n\n## Changing factor reference \n\nChanging the reference group of a factor variable.\n\n- If the object is already a factor then use `relevel()` function and the `ref` argument to specify the reference.\n- If the object is a character then use `factor()` function and `levels` argument to specify the order of the values, the first being the reference.\n\n\nLet's look at the `relevel()` help file\n\n\n\nReorder Levels of Factor\n\nDescription:\n\n     The levels of a factor are re-ordered so that the level specified\n     by 'ref' is first and the others are moved down. This is useful\n     for 'contr.treatment' contrasts which take the first level as the\n     reference.\n\nUsage:\n\n     relevel(x, ref, ...)\n     \nArguments:\n\n       x: an unordered factor.\n\n     ref: the reference level, typically a string.\n\n     ...: additional arguments for future methods.\n\nDetails:\n\n     This, as 'reorder()', is a special case of simply calling\n     'factor(x, levels = levels(x)[....])'.\n\nValue:\n\n     A factor of the same length as 'x'.\n\nSee Also:\n\n     'factor', 'contr.treatment', 'levels', 'reorder'.\n\nExamples:\n\n     warpbreaks$tension <- relevel(warpbreaks$tension, ref = \"M\")\n     summary(lm(breaks ~ wool + tension, data = warpbreaks))\n\n\n\n\n</br>\n\nLet's look at the `factor()` help file\n\n\n\nFactors\n\nDescription:\n\n     The function 'factor' is used to encode a vector as a factor (the\n     terms 'category' and 'enumerated type' are also used for factors).\n     If argument 'ordered' is 'TRUE', the factor levels are assumed to\n     be ordered.  For compatibility with S there is also a function\n     'ordered'.\n\n     'is.factor', 'is.ordered', 'as.factor' and 'as.ordered' are the\n     membership and coercion functions for these classes.\n\nUsage:\n\n     factor(x = character(), levels, labels = levels,\n            exclude = NA, ordered = is.ordered(x), nmax = NA)\n     \n     ordered(x = character(), ...)\n     \n     is.factor(x)\n     is.ordered(x)\n     \n     as.factor(x)\n     as.ordered(x)\n     \n     addNA(x, ifany = FALSE)\n     \n     .valid.factor(object)\n     \nArguments:\n\n       x: a vector of data, usually taking a small number of distinct\n          values.\n\n  levels: an optional vector of the unique values (as character\n          strings) that 'x' might have taken.  The default is the\n          unique set of values taken by 'as.character(x)', sorted into\n          increasing order _of 'x'_.  Note that this set can be\n          specified as smaller than 'sort(unique(x))'.\n\n  labels: _either_ an optional character vector of labels for the\n          levels (in the same order as 'levels' after removing those in\n          'exclude'), _or_ a character string of length 1.  Duplicated\n          values in 'labels' can be used to map different values of 'x'\n          to the same factor level.\n\n exclude: a vector of values to be excluded when forming the set of\n          levels.  This may be factor with the same level set as 'x' or\n          should be a 'character'.\n\n ordered: logical flag to determine if the levels should be regarded as\n          ordered (in the order given).\n\n    nmax: an upper bound on the number of levels; see 'Details'.\n\n     ...: (in 'ordered(.)'): any of the above, apart from 'ordered'\n          itself.\n\n   ifany: only add an 'NA' level if it is used, i.e.  if\n          'any(is.na(x))'.\n\n  object: an R object.\n\nDetails:\n\n     The type of the vector 'x' is not restricted; it only must have an\n     'as.character' method and be sortable (by 'order').\n\n     Ordered factors differ from factors only in their class, but\n     methods and model-fitting functions may treat the two classes\n     quite differently, see 'options(\"contrasts\")'.\n\n     The encoding of the vector happens as follows.  First all the\n     values in 'exclude' are removed from 'levels'. If 'x[i]' equals\n     'levels[j]', then the 'i'-th element of the result is 'j'.  If no\n     match is found for 'x[i]' in 'levels' (which will happen for\n     excluded values) then the 'i'-th element of the result is set to\n     'NA'.\n\n     Normally the 'levels' used as an attribute of the result are the\n     reduced set of levels after removing those in 'exclude', but this\n     can be altered by supplying 'labels'.  This should either be a set\n     of new labels for the levels, or a character string, in which case\n     the levels are that character string with a sequence number\n     appended.\n\n     'factor(x, exclude = NULL)' applied to a factor without 'NA's is a\n     no-operation unless there are unused levels: in that case, a\n     factor with the reduced level set is returned.  If 'exclude' is\n     used, since R version 3.4.0, excluding non-existing character\n     levels is equivalent to excluding nothing, and when 'exclude' is a\n     'character' vector, that _is_ applied to the levels of 'x'.\n     Alternatively, 'exclude' can be factor with the same level set as\n     'x' and will exclude the levels present in 'exclude'.\n\n     The codes of a factor may contain 'NA'.  For a numeric 'x', set\n     'exclude = NULL' to make 'NA' an extra level (prints as '<NA>');\n     by default, this is the last level.\n\n     If 'NA' is a level, the way to set a code to be missing (as\n     opposed to the code of the missing level) is to use 'is.na' on the\n     left-hand-side of an assignment (as in 'is.na(f)[i] <- TRUE';\n     indexing inside 'is.na' does not work).  Under those circumstances\n     missing values are currently printed as '<NA>', i.e., identical to\n     entries of level 'NA'.\n\n     'is.factor' is generic: you can write methods to handle specific\n     classes of objects, see InternalMethods.\n\n     Where 'levels' is not supplied, 'unique' is called.  Since factors\n     typically have quite a small number of levels, for large vectors\n     'x' it is helpful to supply 'nmax' as an upper bound on the number\n     of unique values.\n\n     When using 'c' to combine a (possibly ordered) factor with other\n     objects, if all objects are (possibly ordered) factors, the result\n     will be a factor with levels the union of the level sets of the\n     elements, in the order the levels occur in the level sets of the\n     elements (which means that if all the elements have the same level\n     set, that is the level set of the result), equivalent to how\n     'unlist' operates on a list of factor objects.\n\nValue:\n\n     'factor' returns an object of class '\"factor\"' which has a set of\n     integer codes the length of 'x' with a '\"levels\"' attribute of\n     mode 'character' and unique ('!anyDuplicated(.)') entries.  If\n     argument 'ordered' is true (or 'ordered()' is used) the result has\n     class 'c(\"ordered\", \"factor\")'.  Undocumentedly for a long time,\n     'factor(x)' loses all 'attributes(x)' but '\"names\"', and resets\n     '\"levels\"' and '\"class\"'.\n\n     Applying 'factor' to an ordered or unordered factor returns a\n     factor (of the same type) with just the levels which occur: see\n     also '[.factor' for a more transparent way to achieve this.\n\n     'is.factor' returns 'TRUE' or 'FALSE' depending on whether its\n     argument is of type factor or not.  Correspondingly, 'is.ordered'\n     returns 'TRUE' when its argument is an ordered factor and 'FALSE'\n     otherwise.\n\n     'as.factor' coerces its argument to a factor.  It is an\n     abbreviated (sometimes faster) form of 'factor'.\n\n     'as.ordered(x)' returns 'x' if this is ordered, and 'ordered(x)'\n     otherwise.\n\n     'addNA' modifies a factor by turning 'NA' into an extra level (so\n     that 'NA' values are counted in tables, for instance).\n\n     '.valid.factor(object)' checks the validity of a factor, currently\n     only 'levels(object)', and returns 'TRUE' if it is valid,\n     otherwise a string describing the validity problem.  This function\n     is used for 'validObject(<factor>)'.\n\nWarning:\n\n     The interpretation of a factor depends on both the codes and the\n     '\"levels\"' attribute.  Be careful only to compare factors with the\n     same set of levels (in the same order).  In particular,\n     'as.numeric' applied to a factor is meaningless, and may happen by\n     implicit coercion.  To transform a factor 'f' to approximately its\n     original numeric values, 'as.numeric(levels(f))[f]' is recommended\n     and slightly more efficient than 'as.numeric(as.character(f))'.\n\n     The levels of a factor are by default sorted, but the sort order\n     may well depend on the locale at the time of creation, and should\n     not be assumed to be ASCII.\n\n     There are some anomalies associated with factors that have 'NA' as\n     a level.  It is suggested to use them sparingly, e.g., only for\n     tabulation purposes.\n\nComparison operators and group generic methods:\n\n     There are '\"factor\"' and '\"ordered\"' methods for the group generic\n     'Ops' which provide methods for the Comparison operators, and for\n     the 'min', 'max', and 'range' generics in 'Summary' of\n     '\"ordered\"'.  (The rest of the groups and the 'Math' group\n     generate an error as they are not meaningful for factors.)\n\n     Only '==' and '!=' can be used for factors: a factor can only be\n     compared to another factor with an identical set of levels (not\n     necessarily in the same ordering) or to a character vector.\n     Ordered factors are compared in the same way, but the general\n     dispatch mechanism precludes comparing ordered and unordered\n     factors.\n\n     All the comparison operators are available for ordered factors.\n     Collation is done by the levels of the operands: if both operands\n     are ordered factors they must have the same level set.\n\nNote:\n\n     In earlier versions of R, storing character data as a factor was\n     more space efficient if there is even a small proportion of\n     repeats.  However, identical character strings now share storage,\n     so the difference is small in most cases.  (Integer values are\n     stored in 4 bytes whereas each reference to a character string\n     needs a pointer of 4 or 8 bytes.)\n\nReferences:\n\n     Chambers, J. M. and Hastie, T. J. (1992) _Statistical Models in\n     S_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     '[.factor' for subsetting of factors.\n\n     'gl' for construction of balanced factors and 'C' for factors with\n     specified contrasts.  'levels' and 'nlevels' for accessing the\n     levels, and 'unclass' to get integer codes.\n\nExamples:\n\n     (ff <- factor(substring(\"statistics\", 1:10, 1:10), levels = letters))\n     as.integer(ff)      # the internal codes\n     (f. <- factor(ff))  # drops the levels that do not occur\n     ff[, drop = TRUE]   # the same, more transparently\n     \n     factor(letters[1:20], labels = \"letter\")\n     \n     class(ordered(4:1)) # \"ordered\", inheriting from \"factor\"\n     z <- factor(LETTERS[3:1], ordered = TRUE)\n     ## and \"relational\" methods work:\n     stopifnot(sort(z)[c(1,3)] == range(z), min(z) < max(z))\n     \n     \n     ## suppose you want \"NA\" as a level, and to allow missing values.\n     (x <- factor(c(1, 2, NA), exclude = NULL))\n     is.na(x)[2] <- TRUE\n     x  # [1] 1    <NA> <NA>\n     is.na(x)\n     # [1] FALSE  TRUE FALSE\n     \n     ## More rational, since R 3.4.0 :\n     factor(c(1:2, NA), exclude =  \"\" ) # keeps <NA> , as\n     factor(c(1:2, NA), exclude = NULL) # always did\n     ## exclude = <character>\n     z # ordered levels 'A < B < C'\n     factor(z, exclude = \"C\") # does exclude\n     factor(z, exclude = \"B\") # ditto\n     \n     ## Now, labels maybe duplicated:\n     ## factor() with duplicated labels allowing to \"merge levels\"\n     x <- c(\"Man\", \"Male\", \"Man\", \"Lady\", \"Female\")\n     ## Map from 4 different values to only two levels:\n     (xf <- factor(x, levels = c(\"Male\", \"Man\" , \"Lady\",   \"Female\"),\n                      labels = c(\"Male\", \"Male\", \"Female\", \"Female\")))\n     #> [1] Male   Male   Male   Female Female\n     #> Levels: Male Female\n     \n     ## Using addNA()\n     Month <- airquality$Month\n     table(addNA(Month))\n     table(addNA(Month, ifany = TRUE))\n\n\n\n\n\n## Changing factor reference examples\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group_factor <- relevel(df$age_group_factor, ref=\"young\")\nlevels(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"young\"  \"middle\" \"old\"   \n```\n\n\n:::\n:::\n\n\n\n\nOR\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$age_group_factor <- factor(df$age_group, levels=c(\"young\", \"middle\", \"old\"))\nlevels(df$age_group_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"young\"  \"middle\" \"old\"   \n```\n\n\n:::\n:::\n\n\n\n\nArranging, tabulating, and plotting the data will reflect the new order\n\n\n## Two-dimensional data classes\n\nTwo-dimensional classes are those we would often use to store data read from a file \n\n* a matrix (`matrix` class)\n* a data frame (`data.frame` or `tibble` classes)\n\n\n## Matrices\n\nMatrices, like data frames are also composed of rows and columns. Matrices, unlike `data.frame`, the entire matrix is composed of one R class. **For example: all entries are `numeric`, or all entries are `character`**\n\n`as.matrix()` creates a matrix from a data frame (where all values are the same class). As a reminder, here is the matrix signature function to help remind us how to build a matrix\n\n```\nmatrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)\n```\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(data=1:6, ncol = 2) \n```\n\n::: {.cell-output-display}\n\n\n|   |   |\n|--:|--:|\n|  1|  4|\n|  2|  5|\n|  3|  6|\n:::\n\n```{.r .cell-code}\nmatrix(data=1:6, ncol=2, byrow=TRUE) \n```\n\n::: {.cell-output-display}\n\n\n|   |   |\n|--:|--:|\n|  1|  2|\n|  3|  4|\n|  5|  6|\n:::\n:::\n\n\n\n\nNote, the first matrix filled in numbers 1-6 by columns first and then rows because default `byrow` argument is FALSE. In the second matrix, we changed the argument `byrow` to `TRUE`, and now numbers 1-6 are filled by rows first and then columns.\n\n## Data frame \n\nYou can transform an existing matrix into data frames using `as.data.frame()`  \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.data.frame(matrix(1:6, ncol = 2) ) \n```\n\n::: {.cell-output-display}\n\n\n| V1| V2|\n|--:|--:|\n|  1|  4|\n|  2|  5|\n|  3|  6|\n:::\n:::\n\n\n\n\nYou can create a new data frame out of vectors (and potentially lists, but\nthis is an advanced feature and unusual) by using the `data.frame()` function.\nRecall that all of the vectors that make up a data frame must be the same\nlength.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlotr <- \n  data.frame(\n    name = c(\"Frodo\", \"Sam\", \"Aragorn\", \"Legolas\", \"Gimli\"),\n    race = c(\"Hobbit\", \"Hobbit\", \"Human\", \"Elf\", \"Dwarf\"),\n    age = c(53, 38, 87, 2931, 139)\n  )\n```\n:::\n\n\n\n\n## Numeric variable data summary\n\nData summarization on numeric vectors/variables:\n\n-\t`mean()`: takes the mean of x\n-\t`sd()`: takes the standard deviation of x\n-\t`median()`: takes the median of x\n-\t`quantile()`: displays sample quantiles of x. Default is min, IQR, max\n-\t`range()`: displays the range. Same as `c(min(), max())`\n-\t`sum()`: sum of x\n-\t`max()`: maximum value in x\n-\t`min()`: minimum value in x\n- `colSums()`: get the columns sums of a data frame\n- `rowSums()`: get the row sums of a data frame\n- `colMeans()`: get the columns means of a data frame\n- `rowMeans()`: get the row means of a data frame\n\nNote, all of these functions have an `na.rm` **argument for missing data**.\n\n## Numeric variable data summary\n\nLet's look at a help file for `range()` to make note of the `na.rm` argument\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?range\n```\n:::\n\nRange of Values\n\nDescription:\n\n     'range' returns a vector containing the minimum and maximum of all\n     the given arguments.\n\nUsage:\n\n     range(..., na.rm = FALSE)\n     ## Default S3 method:\n     range(..., na.rm = FALSE, finite = FALSE)\n     ## same for classes 'Date' and 'POSIXct'\n     \n     .rangeNum(..., na.rm, finite, isNumeric)\n     \nArguments:\n\n     ...: any 'numeric' or character objects.\n\n   na.rm: logical, indicating if 'NA''s should be omitted.\n\n  finite: logical, indicating if all non-finite elements should be\n          omitted.\n\nisNumeric: a 'function' returning 'TRUE' or 'FALSE' when called on\n          'c(..., recursive = TRUE)', 'is.numeric()' for the default\n          'range()' method.\n\nDetails:\n\n     'range' is a generic function: methods can be defined for it\n     directly or via the 'Summary' group generic.  For this to work\n     properly, the arguments '...' should be unnamed, and dispatch is\n     on the first argument.\n\n     If 'na.rm' is 'FALSE', 'NA' and 'NaN' values in any of the\n     arguments will cause 'NA' values to be returned, otherwise 'NA'\n     values are ignored.\n\n     If 'finite' is 'TRUE', the minimum and maximum of all finite\n     values is computed, i.e., 'finite = TRUE' _includes_ 'na.rm =\n     TRUE'.\n\n     A special situation occurs when there is no (after omission of\n     'NA's) nonempty argument left, see 'min'.\n\nS4 methods:\n\n     This is part of the S4 'Summary' group generic.  Methods for it\n     must use the signature 'x, ..., na.rm'.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'min', 'max'.\n\n     The 'extendrange()' utility in package 'grDevices'.\n\nExamples:\n\n     (r.x <- range(stats::rnorm(100)))\n     diff(r.x) # the SAMPLE range\n     \n     x <- c(NA, 1:3, -1:1/0); x\n     range(x)\n     range(x, na.rm = TRUE)\n     range(x, finite = TRUE)\n\n\n\n\n## Numeric variable data summary examples\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(df)\n```\n\n::: {.cell-output-display}\n\n\n|   |observation_id |IgG_concentration |     age       |   gender        |    slum         |   log_IgG      | seropos      | age_group       |age_group_factor |\n|:--|:--------------|:-----------------|:--------------|:----------------|:----------------|:---------------|:-------------|:----------------|:----------------|\n|   |Min.   :5006   |Min.   :  0.0054  |Min.   : 1.000 |Length:651       |Length:651       |Min.   :-5.2231 |Mode :logical |Length:651       |young :316       |\n|   |1st Qu.:6306   |1st Qu.:  0.3000  |1st Qu.: 3.000 |Class :character |Class :character |1st Qu.:-1.2040 |FALSE:360     |Class :character |middle:179       |\n|   |Median :7495   |Median :  1.6658  |Median : 6.000 |Mode  :character |Mode  :character |Median : 0.5103 |TRUE :281     |Mode  :character |old   :147       |\n|   |Mean   :7492   |Mean   : 87.3683  |Mean   : 6.606 |NA               |NA               |Mean   : 1.6074 |NA's :10      |NA               |NA's  :  9       |\n|   |3rd Qu.:8749   |3rd Qu.:141.4405  |3rd Qu.:10.000 |NA               |NA               |3rd Qu.: 4.9519 |NA            |NA               |NA               |\n|   |Max.   :9982   |Max.   :916.4179  |Max.   :15.000 |NA               |NA               |Max.   : 6.8205 |NA            |NA               |NA               |\n|   |NA             |NA's   :10        |NA's   :9      |NA               |NA               |NA's   :10      |NA            |NA               |NA               |\n:::\n\n```{.r .cell-code}\nrange(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(df$age, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 15\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(df$IgG_concentration, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.665753\n```\n\n\n:::\n:::\n\n\n\n\n\n## Character variable data summaries\n\nData summarization on character or factor vectors/variables using `table()`\n\n\t\t\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?table\n```\n:::\n\nCross Tabulation and Table Creation\n\nDescription:\n\n     'table' uses cross-classifying factors to build a contingency\n     table of the counts at each combination of factor levels.\n\nUsage:\n\n     table(...,\n           exclude = if (useNA == \"no\") c(NA, NaN),\n           useNA = c(\"no\", \"ifany\", \"always\"),\n           dnn = list.names(...), deparse.level = 1)\n     \n     as.table(x, ...)\n     is.table(x)\n     \n     ## S3 method for class 'table'\n     as.data.frame(x, row.names = NULL, ...,\n                   responseName = \"Freq\", stringsAsFactors = TRUE,\n                   sep = \"\", base = list(LETTERS))\n     \nArguments:\n\n     ...: one or more objects which can be interpreted as factors\n          (including numbers or character strings), or a 'list' (such\n          as a data frame) whose components can be so interpreted.\n          (For 'as.table', arguments passed to specific methods; for\n          'as.data.frame', unused.)\n\n exclude: levels to remove for all factors in '...'.  If it does not\n          contain 'NA' and 'useNA' is not specified, it implies 'useNA\n          = \"ifany\"'.  See 'Details' for its interpretation for\n          non-factor arguments.\n\n   useNA: whether to include 'NA' values in the table.  See 'Details'.\n          Can be abbreviated.\n\n     dnn: the names to be given to the dimensions in the result (the\n          _dimnames names_).\n\ndeparse.level: controls how the default 'dnn' is constructed.  See\n          'Details'.\n\n       x: an arbitrary R object, or an object inheriting from class\n          '\"table\"' for the 'as.data.frame' method. Note that\n          'as.data.frame.table(x, *)' may be called explicitly for\n          non-table 'x' for \"reshaping\" 'array's.\n\nrow.names: a character vector giving the row names for the data frame.\n\nresponseName: the name to be used for the column of table entries,\n          usually counts.\n\nstringsAsFactors: logical: should the classifying factors be returned\n          as factors (the default) or character vectors?\n\nsep, base: passed to 'provideDimnames'.\n\nDetails:\n\n     If the argument 'dnn' is not supplied, the internal function\n     'list.names' is called to compute the 'dimname names' as follows:\n     If '...' is one 'list' with its own 'names()', these 'names' are\n     used.  Otherwise, if the arguments in '...' are named, those names\n     are used.  For the remaining arguments, 'deparse.level = 0' gives\n     an empty name, 'deparse.level = 1' uses the supplied argument if\n     it is a symbol, and 'deparse.level = 2' will deparse the argument.\n\n     Only when 'exclude' is specified (i.e., not by default) and\n     non-empty, will 'table' potentially drop levels of factor\n     arguments.\n\n     'useNA' controls if the table includes counts of 'NA' values: the\n     allowed values correspond to never ('\"no\"'), only if the count is\n     positive ('\"ifany\"') and even for zero counts ('\"always\"').  Note\n     the somewhat \"pathological\" case of two different kinds of 'NA's\n     which are treated differently, depending on both 'useNA' and\n     'exclude', see 'd.patho' in the 'Examples:' below.\n\n     Both 'exclude' and 'useNA' operate on an \"all or none\" basis.  If\n     you want to control the dimensions of a multiway table separately,\n     modify each argument using 'factor' or 'addNA'.\n\n     Non-factor arguments 'a' are coerced via 'factor(a,\n     exclude=exclude)'.  Since R 3.4.0, care is taken _not_ to count\n     the excluded values (where they were included in the 'NA' count,\n     previously).\n\n     The 'summary' method for class '\"table\"' (used for objects created\n     by 'table' or 'xtabs') which gives basic information and performs\n     a chi-squared test for independence of factors (note that the\n     function 'chisq.test' currently only handles 2-d tables).\n\nValue:\n\n     'table()' returns a _contingency table_, an object of class\n     '\"table\"', an array of integer values.  Note that unlike S the\n     result is always an 'array', a 1D array if one factor is given.\n\n     'as.table' and 'is.table' coerce to and test for contingency\n     table, respectively.\n\n     The 'as.data.frame' method for objects inheriting from class\n     '\"table\"' can be used to convert the array-based representation of\n     a contingency table to a data frame containing the classifying\n     factors and the corresponding entries (the latter as component\n     named by 'responseName').  This is the inverse of 'xtabs'.\n\nReferences:\n\n     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S\n     Language_.  Wadsworth & Brooks/Cole.\n\nSee Also:\n\n     'tabulate' is the underlying function and allows finer control.\n\n     Use 'ftable' for printing (and more) of multidimensional tables.\n     'margin.table', 'prop.table', 'addmargins'.\n\n     'addNA' for constructing factors with 'NA' as a level.\n\n     'xtabs' for cross tabulation of data frames with a formula\n     interface.\n\nExamples:\n\n     require(stats) # for rpois and xtabs\n     ## Simple frequency distribution\n     table(rpois(100, 5))\n     ## Check the design:\n     with(warpbreaks, table(wool, tension))\n     table(state.division, state.region)\n     \n     # simple two-way contingency table\n     with(airquality, table(cut(Temp, quantile(Temp)), Month))\n     \n     a <- letters[1:3]\n     table(a, sample(a))                    # dnn is c(\"a\", \"\")\n     table(a, sample(a), dnn = NULL)        # dimnames() have no names\n     table(a, sample(a), deparse.level = 0) # dnn is c(\"\", \"\")\n     table(a, sample(a), deparse.level = 2) # dnn is c(\"a\", \"sample(a)\")\n     \n     ## xtabs() <-> as.data.frame.table() :\n     UCBAdmissions ## already a contingency table\n     DF <- as.data.frame(UCBAdmissions)\n     class(tab <- xtabs(Freq ~ ., DF)) # xtabs & table\n     ## tab *is* \"the same\" as the original table:\n     all(tab == UCBAdmissions)\n     all.equal(dimnames(tab), dimnames(UCBAdmissions))\n     \n     a <- rep(c(NA, 1/0:3), 10)\n     table(a)                 # does not report NA's\n     table(a, exclude = NULL) # reports NA's\n     b <- factor(rep(c(\"A\",\"B\",\"C\"), 10))\n     table(b)\n     table(b, exclude = \"B\")\n     d <- factor(rep(c(\"A\",\"B\",\"C\"), 10), levels = c(\"A\",\"B\",\"C\",\"D\",\"E\"))\n     table(d, exclude = \"B\")\n     print(table(b, d), zero.print = \".\")\n     \n     ## NA counting:\n     is.na(d) <- 3:4\n     d. <- addNA(d)\n     d.[1:7]\n     table(d.) # \", exclude = NULL\" is not needed\n     ## i.e., if you want to count the NA's of 'd', use\n     table(d, useNA = \"ifany\")\n     \n     ## \"pathological\" case:\n     d.patho <- addNA(c(1,NA,1:2,1:3))[-7]; is.na(d.patho) <- 3:4\n     d.patho\n     ## just 3 consecutive NA's ? --- well, have *two* kinds of NAs here :\n     as.integer(d.patho) # 1 4 NA NA 1 2\n     ##\n     ## In R >= 3.4.0, table() allows to differentiate:\n     table(d.patho)                   # counts the \"unusual\" NA\n     table(d.patho, useNA = \"ifany\")  # counts all three\n     table(d.patho, exclude = NULL)   #  (ditto)\n     table(d.patho, exclude = NA)     # counts none\n     \n     ## Two-way tables with NA counts. The 3rd variant is absurd, but shows\n     ## something that cannot be done using exclude or useNA.\n     with(airquality,\n        table(OzHi = Ozone > 80, Month, useNA = \"ifany\"))\n     with(airquality,\n        table(OzHi = Ozone > 80, Month, useNA = \"always\"))\n     with(airquality,\n        table(OzHi = Ozone > 80, addNA(Month)))\n\n\n\n\n\n## Character variable data summary examples\n\nNumber of observations in each category\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df$gender)\n```\n\n::: {.cell-output-display}\n\n\n| Female| Male|\n|------:|----:|\n|    325|  326|\n:::\n\n```{.r .cell-code}\ntable(df$gender, useNA=\"always\")\n```\n\n::: {.cell-output-display}\n\n\n| Female| Male| NA|\n|------:|----:|--:|\n|    325|  326|  0|\n:::\n\n```{.r .cell-code}\ntable(df$age_group, useNA=\"always\")\n```\n\n::: {.cell-output-display}\n\n\n| middle| old| young| NA|\n|------:|---:|-----:|--:|\n|    179| 147|   316|  9|\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df$gender)/nrow(df) #if no NA values\n```\n\n::: {.cell-output-display}\n\n\n|   Female|     Male|\n|--------:|--------:|\n| 0.499232| 0.500768|\n:::\n\n```{.r .cell-code}\ntable(df$age_group)/nrow(df[!is.na(df$age_group),]) #if there are NA values\n```\n\n::: {.cell-output-display}\n\n\n|    middle|      old|     young|\n|---------:|--------:|---------:|\n| 0.2788162| 0.228972| 0.4922118|\n:::\n\n```{.r .cell-code}\ntable(df$age_group)/nrow(subset(df, !is.na(df$age_group),)) #if there are NA values\n```\n\n::: {.cell-output-display}\n\n\n|    middle|      old|     young|\n|---------:|--------:|---------:|\n| 0.2788162| 0.228972| 0.4922118|\n:::\n:::\n\n\n\n\n\n## Summary\n\n- You can create new columns/variable to a data frame by using `$`  or the `transform()` function\n- One useful function for creating new variables based on existing variables is the `ifelse()` function, which returns a value depending on whether the element of test is `TRUE` or `FALSE`\n- The `class()` function allows you to evaluate the class of an object.\n-  There are two types of numeric class objects: integer and double\n-  Logical class objects only have `TRUE` or `FALSE` or `NA` (without quotes)\n-  `is.CLASS_NAME(x)` can be used to test the class of an object x\n-  `as.CLASS_NAME(x)` can be used to change the class of an object x\n-  Factors are a special character class that has levels \n- There are many fairly intuitive data summary functions you can perform on a vector (i.e., `mean()`, `sd()`, `range()`) or on rows or columns of a data frame (i.e., `colSums()`, `colMeans()`, `rowSums()`)\n- The `table()` function builds frequency tables of the counts at each combination of categorical levels\n\n## Acknowledgements\n\nThese are the materials we looked through, modified, or extracted to complete this module's lecture.\n\n-   [\"Introduction to R for Public Health Researchers\" Johns Hopkins University](https://jhudatascience.org/intro_to_r/)\n\n",
    "supporting": [
      "Module07-VarCreationClassesSummaries_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}