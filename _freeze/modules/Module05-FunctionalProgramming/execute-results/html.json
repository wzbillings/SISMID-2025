{
  "hash": "17437baeea29fcb97f38b85bf7b58583",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Module 5: FunctionalProgramming\"\nformat:\n  revealjs:\n    toc: false\n---\n\n\n\n\n\n\n\n## Learning goals\n\n1. Define functional programming\n1. Use functional programming tools in base R to repeat multiple functional calls.\n1. Use the `purrr` package for easily mapping and reducing functions.\n\n## What is functional programming?\n\n. . .\n\n- All of our code is functional if it does its job?\n\n. . .\n\n- Yes, but we are using the technical definition of functional programming: programming that is based on functions.\n\n. . .\n\n- Specifically, we want to be able to compose functions, which you might remember hating in precalculus.\n\n$$g \\circ f = g(f(x))$$\n\n- In computer science, a **functional** is a function that accepts a function as an argument.\n\n## Functional vs. imperative programming\n\n- So far, we've been using **imperative** programming: we save variables, and we update them with new commands. Our code is structured as a list of instructions.\n\n- In **functional** programming, we write everything as a function, and we get the results we want by composing many functions.\n\n. . .\n\n- But we're just going to show you some useful parts of functional programming that you can include in your regular code.\n\n## Ok, but why?\n\n- Recall our function from the previous Module.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_country_stats <- function(df, iso3_code){\n\t\n\tcountry_data <- subset(df, iso3c == iso3_code)\n\t\n\t# Get the summary statistics for this country\n\tcountry_cases <- country_data$measles_cases\n\tcountry_quart <- quantile(\n\t\tcountry_cases, na.rm = TRUE, probs = c(0.25, 0.5, 0.75)\n\t)\n\tcountry_range <- range(country_cases, na.rm = TRUE)\n\t\n\tcountry_name <- unique(country_data$country)\n\t\n\tcountry_summary <- data.frame(\n\t\tcountry = country_name,\n\t\tmin = country_range[[1]],\n\t\tQ1 = country_quart[[1]],\n\t\tmedian = country_quart[[2]],\n\t\tQ3 = country_quart[[3]],\n\t\tmax = country_range[[2]]\n\t)\n\t\n\treturn(country_summary)\n}\n```\n:::\n\n\n\n\n. . .\n\n- We could write a loop to get stats for many countries.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeas <- readRDS(here::here(\"data\", \"measles_final.Rds\"))\ncountry_codes <- c(\"IND\", \"PAK\", \"BGD\", \"NPL\")\n\n# Loop setup\nout <- vector(mode = \"list\", length = length(country_codes))\nfor (i in 1:length(out)) {\n\tout[[i]] <- get_country_stats(meas, country_codes[[i]])\t\n}\n\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n  country  min      Q1  median       Q3    max\n1   India 3305 31135.5 47109.5 80797.25 252940\n\n[[2]]\n   country min     Q1 median    Q3   max\n1 Pakistan 386 2065.5 4075.5 17422 55543\n\n[[3]]\n     country min      Q1 median     Q3   max\n1 Bangladesh 203 2193.75 5270.5 9889.5 27327\n\n[[4]]\n  country min  Q1 median   Q3   max\n1   Nepal  59 190   1268 3100 13344\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n- But if we use a functional programming tool called `lapply`, look how easy it is!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout2 <- lapply(country_codes, function(c) get_country_stats(meas, c))\nout2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n  country  min      Q1  median       Q3    max\n1   India 3305 31135.5 47109.5 80797.25 252940\n\n[[2]]\n   country min     Q1 median    Q3   max\n1 Pakistan 386 2065.5 4075.5 17422 55543\n\n[[3]]\n     country min      Q1 median     Q3   max\n1 Bangladesh 203 2193.75 5270.5 9889.5 27327\n\n[[4]]\n  country min  Q1 median   Q3   max\n1   Nepal  59 190   1268 3100 13344\n```\n\n\n:::\n:::\n\n\n\n\n- Functional programming techniques can help us avoid writing messy loops and clean up our code.\n\n## Ok, but why?\n\n- R is a functional programming language at its core.\n- In R, functions are objects like everything else.\n- You never *have* to use FP, but it can help you write neater code.\n- More information: https://adv-r.hadley.nz/fp.html.\n\n## Anonymous functions\n\n- In this code, you can see the keyword `function`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout2 <- lapply(country_codes, function(c) get_country_stats(meas, c))\n```\n:::\n\n\n\n\n. . .\n\n- The function `function(c) get_country_stats(meas, c)` is called an **anonymous function** (or sometimes a lambda).\n- It's anonymous because it has no name assigned -- this is just a shortcut for when you only need a function once.\n- In R, you can also write `\\(c) ...` as a shortcut for writing `function(c) ...` as an anonymous function.\n\n. . .\n\n- This code works just as well, but can be a bit of a hassle.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_country_stats_from_meas <- function(c) get_country_stats(meas, c)\nout3 <- lapply(country_codes, get_country_stats_from_meas)\n```\n:::\n\n\n\n\n## `*apply()` and friends {.incremental}\n\n- R includes many functional programming tools collectively called `*apply()`. Here are the specific ones that are most useful:\n- `lapply()`: repeat the function on a list of things.\n- `sapply()`: same as `lapply()` but try to simplify the output to a matrix or vector.\n- `apply()`: repeat the function over the rows (`margin = 1`) or columns (`margin = 2`) of a matrix.\n- `tapply()`: repeat the function over combinations of grouping factors.\n\n## A `tapply()` example {.scrollable}\n\n- `tapply()`: repeat the function over combinations of grouping factors.\n- We want to get the average vaccine coverage for each country in the measles dataset -- we need to separate this by the two vaccines as well.\n- This is pretty easy to do with `tapply()`.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeas <- readRDS(here::here(\"data\", \"measles_final.Rds\"))\nmeas_long <- meas |>\n\ttidyr::pivot_longer(\n\t\tdplyr::starts_with(\"MCV\"),\n\t\tnames_to = \"vaccine_antigen\",\n\t\tvalues_to = \"vaccine_coverage\"\n\t)\nout <- tapply(\n\tmeas_long$vaccine_coverage,\n\tlist(meas_long$iso3c, meas_long$vaccine_antigen),\n\tFUN = mean\n)\nhead(out)\n```\n\n::: {.cell-output-display}\n\n\n|    | MCV1_coverage| MCV2_coverage|\n|:---|-------------:|-------------:|\n|ABW |            NA|            NA|\n|AFG |            NA|            NA|\n|AGO |            NA|            NA|\n|AIA |            NA|            NA|\n|ALB |            NA|            NA|\n|AND |            NA|            NA|\n:::\n:::\n\n\n\n\n. . .\n\n- Uh oh.\n\n. . .\n\n- If we want to handle the missing values, we can use an anonymous function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- tapply(\n\tmeas_long$vaccine_coverage,\n\tlist(meas_long$iso3c, meas_long$vaccine_antigen),\n\tFUN = \\(x) mean(x, na.rm = TRUE)\n)\nhead(out)\n```\n\n::: {.cell-output-display}\n\n\n|    | MCV1_coverage| MCV2_coverage|\n|:---|-------------:|-------------:|\n|ABW |           NaN|           NaN|\n|AFG |      41.80952|      31.73684|\n|AGO |      47.17500|      22.75000|\n|AIA |           NaN|           NaN|\n|ALB |      93.30233|      96.00000|\n|AND |      96.53846|      89.56250|\n:::\n:::\n\n\n\n\n## You try it with `lapply()`!\n\n- Read in all sheets of the `QCRC_FINAL_Deidentified.xlsx` data using a vector of sheet names and `lapply`.\n\n. . .\n\n- Hint:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_file <- here::here(\"data\", \"QCRC_FINAL_Deidentified.xlsx\")\nsheet_names <- readxl::excel_sheets(data_file)\nsheet_list <- lapply(\n\tsheet_names,\n\t\\(name) ...\n)\n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_file <- here::here(\"data\", \"QCRC_FINAL_Deidentified.xlsx\")\nsheet_names <- readxl::excel_sheets(data_file)\nsheet_list <- lapply(\n\tsheet_names,\n\t\\(name) readxl::read_excel(data_file, sheet = name)\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in D6716 / R6716C4: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in G7843 / R7843C7: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in D7844 / R7844C4: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in E7845 / R7845C5: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in G10671 / R10671C7: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in D10672 / R10672C4: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in E10673 / R10673C5: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in G11539 / R11539C7: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in D11540 / R11540C4: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in G17408 / R17408C7: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in D17409 / R17409C4: got 'Date\\Time Correction'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Expecting numeric in E17410 / R17410C5: got 'Date\\Time Correction'\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(sheet_list, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 10\n $ : tibble [288 × 37] (S3: tbl_df/tbl/data.frame)\n $ : tibble [42,606 × 6] (S3: tbl_df/tbl/data.frame)\n $ : tibble [288 × 8] (S3: tbl_df/tbl/data.frame)\n $ : tibble [15,919 × 29] (S3: tbl_df/tbl/data.frame)\n $ : tibble [143,220 × 11] (S3: tbl_df/tbl/data.frame)\n $ : tibble [18,281 × 11] (S3: tbl_df/tbl/data.frame)\n $ : tibble [5,252 × 5] (S3: tbl_df/tbl/data.frame)\n $ : tibble [869,554 × 7] (S3: tbl_df/tbl/data.frame)\n $ : tibble [288 × 71] (S3: tbl_df/tbl/data.frame)\n $ : tibble [3,612 × 36] (S3: tbl_df/tbl/data.frame)\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## An `apply()` example\n\n- You'll use `apply()` less often because it's specifically for matrices, where all data types have to be the same.\n- First, make a matrix from the QCRC main dataset that only has the columns `Died`, `30D_Mortality`, and `60D_Mortality`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_matrix <- sheet_list[[1]] |>\n\tdplyr::select(Died, `30D_Mortality`, `60D_Mortality`) |>\n\tas.matrix()\n\nhead(d_matrix)\n```\n\n::: {.cell-output-display}\n\n\n| Died| 30D_Mortality| 60D_Mortality|\n|----:|-------------:|-------------:|\n|    1|             1|             1|\n|    0|             0|             0|\n|    0|             0|             0|\n|    1|             1|             1|\n|    1|             1|             1|\n|    1|             1|             1|\n:::\n:::\n\n\n\n\n- Next use `apply` with the correct choice of `MARGIN` and `FUN` to get the proportion of cases that resulted in death at all three time points in one function call.\n\n. . .\n\n- Hint:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(\n\td_matrix,\n\tMARGIN = (1 or 2),\n\tFUN = some_function\n)\n```\n:::\n\n\n\n\n- Another hint: you can tell if you chose the correct `MARGIN` argument by counting the number of elements in the output. There should be 3, one for each column.\n\n. . .\n\n- Solution:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(\n\td_matrix,\n\tMARGIN = 2,\n\tFUN = mean\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         Died 30D_Mortality 60D_Mortality \n    0.3402778     0.3263889     0.3333333 \n```\n\n\n:::\n:::\n\n\n\n\n## You try it!\n\n- Load the measles dataset. Filter the dataset so you only have records from 2005, and only have complete cases.\n- Then, use `split` to split the dataframe into a list by `region`.\n- Now, use `lapply()` to fit a Poisson `glm` for each region separately that includes effects of MCV1 and MCV2 coverage.\n- Find a way, using `lapply()` or `sapply()`, `coef()`, and `do.call()` to make a nice matrix of the coefficients.\n\n. . .\n\n- Solution for data processing\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeas <- readr::read_rds(here::here(\"data\", \"measles_final.Rds\"))\nmeas_2005 <- meas |>\n\tdplyr::filter(year == 2005) |>\n\ttidyr::drop_na()\n\nmeas_regions <- split(meas_2005, meas_2005$region)\n```\n:::\n\n\n\n\n. . .\n\n- Hint\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_list <- lapply(\n\tmeas_regions,\n\t\\(d) glm(...)\n)\nmodel_coefs_list <- lapply(model_list, ...)\nmodel_coefs_mat <- do.call(...)\n```\n:::\n\n\n\n\n\n. . .\n\n- Solution\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_list <- lapply(\n\tmeas_regions,\n\t\\(d) glm(\n\t\tmeasles_cases ~ MCV1_coverage + MCV2_coverage,\n\t\tdata = d, family = \"poisson\"\n\t)\n)\nmodel_coefs_list <- lapply(model_list, coef)\nmodel_coefs_mat <- do.call(rbind, model_coefs_list)\n\nmodel_coefs_mat\n```\n\n::: {.cell-output-display}\n\n\n|         | (Intercept)| MCV1_coverage| MCV2_coverage|\n|:--------|-----------:|-------------:|-------------:|\n|Africa   |   17.676171|    -0.2813935|     0.1419766|\n|Americas |    7.278677|    -0.0790399|     0.0169828|\n|Asia     |   11.417256|    -0.0440387|     0.0143116|\n|Europe   |  -12.027052|     0.1838390|     0.0008544|\n|Oceania  |   -8.355161|     0.1176879|    -0.0257241|\n:::\n:::\n\n\n\n\n## Summary\n\n- Functional programming tools like `*apply()` take a function as an input and use the same function multiple times.\n- In R, functions are objects like everything else and manipulating them like objects can help us write readable, fast code.\n\n. . .\n\n- Side note: `purrr` is a modern version of `*apply()` with a more consistent interface. It's worth learning and covered in the [Advanced R book](https://adv-r.hadley.nz/fp.html), but most people still use `*apply()`.\n- This book also covers more standard FP tools like reduction and filtering that we didn't have time to talk about.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}